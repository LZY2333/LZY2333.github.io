---
title: 二叉树
date: 2021-09-17 16:47:30
categories: 技术栈
tags: 
    - 算法
---

# 二叉树

代码实现部分参考了

[徐小夕的掘金文章<JS进阶必备的二叉树知识>](https://juejin.cn/post/6844904200644591623)

## 树
__非线性表结构__

__父节点__ __子节点__ __兄弟节点__:
节点 储存数据 同时储存 子节点的指针,同一节点下的 所有子节点 互为兄弟节点

__根节点__:没有父节点 的节点

__叶子节点__:没有子节点 的节点

节点的
__高度(Height)__:当前节点到叶子节点的边数(叶子节点为0,根节点为 层数-1)
__深度(Depth)__:根节点到这个节点的边数(根节点为0,叶子节点为 层数-1)
__层(Level)__:节点的深度 +1(根节点为1,叶子节点为 深度+1)

深度 从上往下数(如水深),初始0; 高度 从下往上数(如楼房),初始0.
层数 同深度,但初始为1
__树的高度__:根节点的高度

## 二叉树

由一个空节点 或 两颗不相交二叉树组成(递归定义)

__满二叉树__ 除了叶子节点 每个节点都有左右两个节点

__完全二叉树__ 除了最后一层,其他层都是满节点,叶子节点都在左边.

## 如何储存一个二叉树

__链式储存法__ 基于链表,每个节点三个字段,一个存数据,两个存左右节点的指针.

__顺序储存法__ 
完全二叉树:

1.基于数组,根节点放在i=1的位置,一层一层从左往下,依次放入数组.

2.此时,如果节点X在i位置,左子节点就是2 * i,右子节点就是2 * i + 1,
反之i/2就是父节点.

非完全二叉树:
按照上面 (2.)的方式放入数组,但会有较多空余空间

> 完全二叉树用数组储存更节省空间(不需要额外空间储存指针)
> 堆其实是一种完全二叉树,最常用的储存方式就是数组

## 二叉树的遍历

__前序遍历__: 当前节点 左子树 右子树
__中序遍历__: 左子树 当前节点 右子树
__后序遍历__: 左子树 右子树 当前节点

> preOrder(DLR) inOrder(LDR) postOrder(LRD) + traversal
> 前中后 代表 前中后的位置打印当前节点

```js
// 前序遍历,其他两个就是换个cb的位置
this.preOrderTraversal = function(cb) {
    preOrderTraverseNode(root, cb)
}

function preOrderTraverseNode(node, cb) {
    if(node == null) { return }
    cb(node.key)
    preOrderTraverseNode(node.left, cb)
    preOrderTraverseNode(node.right, cb)
}
```

__层序遍历__

代码实现,借用队列辅助即可,根节点先入队列,

然后循环从队列中pop节点,将pop出来的节点的左子节点先入队列,右节点后入队列,

依次循环,直到队列为空,遍历结束

## 二叉查找树(BinarySearchTree)

```js
// 基类
function BinarySearchTree() {
    let Node = function(key) {
        this.key = key;
        this.left = null;
        this.right = null;
    }
    let root = null;
}
```

```js
// 插入
this.insert = function(key) {
    let newNode = new Node(key);
    if(root === null) root = newNode
    else insertNode(root, newNode)
}
function insertNode(node, newNode) {
    if(newNode.key < node.key) {
        if(node.left === null) node.left = newNode
        else insertNode(node.left, newNode)
    }else {
        if(node.right === null) node.right = newNode
        else insertNode(node.right, newNode)
    }
}
```


```js
// 搜索特定值
this.search = function(key) {
    return searchNode(root, key)
}

function searchNode(node, key) {
    if(node === null) {
        return false
    }
    if(key < node.key) {
        return searchNode(node.left, key)
    }else if(key > node.key) {
        return searchNode(node.right, key)
    }else {
        return true
    }
}

// 搜索最小值
this.min = function() {
    return minNode(root)
}
function minNode(node) {
    if(node) {
        while(node && node.left !== null) {
            node = node.left;
        }
        return node.key
    }
    return null
}

// 搜索最大值
this.max = function() {
    return maxNode(root)
}
function maxNode(node) {
    if(node) {
        while(node && node.right !== null) {
            node = node.right;
        }
        return node.key
    }
    return null
}
```

```js
// 删除节点
this.remove = function(key) {
    root = removeNode(root, key)
}

function removeNode(node, key) {
    if(node === null) {
        return null
    }
    if(key < node.key) {
        node.left = removeNode(node.left, key)
        return node
    }else if(key > node.key) {
        node.right = removeNode(node.right, key)
        return node
    }else {
        // 一个叶节点
        if(node.left === null && node.right === null) {
            node = null;
            return node
        }
        // 只有一个子节点的节点
        if(node.left === null) {
            node = node.right;
            return node
        }else if(node.right === null) {
            node = node.left;
            return node
        }
        // 有两个子节点的节点情况
        let aux = findMinNode(node.right);
        node.key = aux.key;
        node.right = removeNode(node.right, aux.key);
        return node
    }
}

function findMinNode(node) {
    if(node) {
        while(node && node.left !== null) {
            node = node.left;
        }
        return node
    }
    return null
}
```