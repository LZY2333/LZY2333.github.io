---
title: 二叉树
date: 2021-09-17 16:47:30
categories: 技术栈
tags: 
    - 算法
---

# 二叉树

## 树
__非线性表结构__

__父节点__ __子节点__ __兄弟节点__:
节点 储存数据 同时储存 子节点的指针,同一节点下的 所有子节点 互为兄弟节点

__根节点__:没有父节点 的节点

__叶子节点__:没有子节点 的节点

节点的
__高度(Height)__:当前节点到叶子节点的边数(叶子节点为0,根节点为 层数-1)
__深度(Depth)__:根节点到这个节点的边数(根节点为0,叶子节点为 层数-1)
__层(Level)__:节点的深度 +1(根节点为1,叶子节点为 深度+1)

深度 从上往下数(如水深),初始0; 高度 从下往上数(如楼房),初始0.
层数 同深度,但初始为1
__树的高度__:根节点的高度

## 二叉树

由一个空节点 或 两颗不相交二叉树组成(递归定义)

__满二叉树__ 除了叶子节点 每个节点都有左右两个节点

__完全二叉树__ 除了最后一层,其他层都是满节点,叶子节点都在左边.

## 如何储存一个二叉树

__链式储存法__ 基于链表,每个节点三个字段,一个存数据,两个存左右节点的指针.

__顺序储存法__ 
完全二叉树:

1.基于数组,根节点放在i=1的位置,一层一层从左往下,依次放入数组.

2.此时,如果节点X在i位置,左子节点就是2 * i,右子节点就是2 * i + 1,
反之i/2就是父节点.

非完全二叉树:
按照上面 (2.)的方式放入数组,但会有较多空余空间

> 完全二叉树用数组储存更节省空间(不需要额外空间储存指针)
> 堆其实是一种完全二叉树,最常用的储存方式就是数组

## 二叉树的遍历

__前序遍历__: 当前节点 左子树 右子树
__中序遍历__: 左子树 当前节点 右子树
__后序遍历__: 左子树 右子树 当前节点

> preOrder(DLR) inOrder(LDR) postOrder(LRD) + traversal
> 前中后 代表 前中后的位置打印当前节点

```js
// 前序遍历,递归,其他两个遍历就是换个push的位置
var preOrderTraversal = function(root) {
    let result = []
    function preOrderTraverseNode(p) {
        if(!p) return
        result.push(p.val)
        preOrderTraverseNode(p.left)
        preOrderTraverseNode(p.right)
    }
    preOrderTraverseNode(root)
    return result
}
```

```js
// 前序遍历,迭代,双90
var preOrderTraversal = function(root) {
    let result = [],stack = [],p = root
    while(p) {
        result.push(p.val)
        if(p.left && p.right) {
            stack.push(p.right)
            p = p.left
        } else if(p.left) {
            p = p.left
        } else if(p.right) {
            p = p.right
        } else {
            p = stack.pop()
        }
    }
    return result
}
```

```js
// 中序遍历,迭代
var inOrderTraversal = function(root) {
    let result = [],stack = [],p = root
    while(p || stack.length) {
        while(p) { // 把左节点全部存起来
            // result.push(p.val) // 写这里就是前序遍历
            stack.push(p)
            p = p.left
        }
        p = stack.pop() // 再输出所有左节点(配合上外层while)
        result.push(p.val)
        p = p.right // 每输出一个左节点，查看一下他的右子树
    }
    return result
};
```

__层序遍历__

代码实现,借用队列辅助即可,根节点先入队列,

然后循环从队列中pop节点,将pop出来的节点的左子节点先入队列,右节点后入队列,

依次循环,直到队列为空,遍历结束

## 二叉查找树(BinarySearchTree)

结构特殊点:

__树中任意一个节点,左子树所有节点都小于这个节点,右子树所有节点都大于这个节点.__

优点:

__快速查找/插入/删除__ __快速查找最大最小节点/前驱节点/后继节点__

__中序遍历二叉查找树,可输出有序数据,时间复杂度O(n),非常高效__


### 插入操作

1.从根节点开始,依次比较插入的数据与节点的大小关系

2.如果插入的数据更大 且节点右子树为空,插入右子节点位置

3.如果插入的数据更大 且节点有子树不为空,继续递归遍历右子树.

4.如果插入的数据更小 同上改左子树.....


### 查找操作

1.从根节点开始,依次比较要查找的数据与节点的大小关系

2.如果等于,就返回

3.如果更小,就在左子树按步骤继续查找.

4.如果更大,就在右子树按步骤继续查找.

### 删除操作

1.从根节点开始,找到要删除的节点P,与其父节点PP

2.如果 P 左右子树均存在,从左子树找最大值min,或右子树找最小值min 接替 p

3.并将要删除的节点 P改为 min(min复制到了要删除的节点P的位置),同情况第4步(min必然非左右子节点均存在)

4.如果 P 左右子树之一不存在,或都不存在,P 的child(无论左右哪一个,或者null) 取代 P的位置

> 或者单纯将 要删除的节点标价为"已删除"

### 支持重复数据

实际开发过程中,利用对象中的某个字段作为key值构建二叉查找树,对象中的其他字段称为卫星数据

如果key值存在重复的情况,如何解决

1. 每一个节点储存一个链表或动态扩容的数组,将值储存在同一个节点上

2. 相同数据插入右子树(相同的当作大于的来处理)

> 2中,查找时,遇到相同的节点,不能停止查找,继续在右子树查找,直到遇到叶子节点,返回所有相同值节点
> 2中,删除时,要先查找到每个要删除的节点,再按之前的删除

### 时间复杂度

不同形状的树 查找 的时间复杂度不同,最差退化成链表O(n),普通O(logn)

__时间复杂度与树的高度成正比,也就是O(height)__

平衡二叉树 插入、删除、查找操作的时间复杂度比较稳定,是 O(logn)

__确定二叉树高度算法__

1.深度优先思想的递归,分别求左右子树的高度,当前节点的高度就是左右子树中较大的那个+1

2.第二种可以采用层次遍历的方式,每一层记录都记录下当前队列的长度,

这个是队尾,每一层队头从0开始.然后每遍历一个元素,队头下标+1.

直到队头下标等于队尾下标.这个时候表示当前层遍历完成.

每一层刚开始遍历的时候,树的高度+1.最后队列为空,就能得到树的高度.

## 自己写的实现

```js
class TreeNode {
    constructor(val) {
        this.val = val
        this.left = null
        this.right = null
    }
}
class BinarySearchTree {
    constructor() {
        this.root = null
    }
    // 插入
    insert(val) {
        const newNode = new TreeNode(val)
        if(!this.root) {
            this.root = newNode
            return
        }
        let p = this.root
        while(p) {
            if(val < p.val) {
                if(!p.left) {
                    p.left = newNode
                    return
                }
                p = p.left
            } else {
                if(!p.right) {
                    p.right = newNode
                    return
                }
                p = p.right
            }
        }
    }
    // 查找
    find(val) {
        let p = this.root
        while(p && p.val !== val) {
            p = val < p.val ? p.left : p.right
        }
        return p
    }
    // 删除
    delete(val) {
        let p = this.root // 要删除的节点 p
        let pp = null // 要删除的节点的父节点 pp
        while(p && p.val !== val) { // 找到p,每轮while结束,pp都指向p父节点
            pp = p
            p = val < p.val ? p.left : p.right
        }

        if(!p) return null
        if(p.left && p.right) { // 1. 要删除的节点p 左右子树均存在
            let minP = p.right // p右子节点中最小的数,刚好大于P的数minP
            let minPP = P // minP的父节点

            while(minP.left) { // 找出minP接替被删除的P
                minPP = minP
                minP = minP.left
            }

            p.val = minP.val // minP接替p,删除p
            p = minP // p指向minP,要删除的节点变为minP,因为minP已接替了p
            pp = minPP // 继续指向p的父节点,此时的p必然无左子节点,归入情况2去删除
        }

        let child = null // 2. 要删除的节点p 左子树或右子树之一存在,null都不存在
        if(p.left) child = p.left
        else if(p.right) child = p.right
        
        // 左子树或右子树之一存在,或都不存在,只要拿p子节点代替p位置就行,不需要考虑child来着p哪个子树
        if(pp === null) this.root = child // pp等于null代表,p就是根节点,同时p不是左右子树都存在
        else if(pp.left = p) pp.left = child
        else pp.right = child
    }
}
```

## 二叉树与散列表

散列表的插入、删除、查找操作的时间复杂度可以做到常量级的 O(1),非常高效

二叉查找树在比较平衡的情况下,插入、删除、查找操作时间复杂度才是 O(logn)

平衡二叉树 对比 散列表的优势:

1. __有序数据__

散列表是数据无序,二叉树中序遍历O(n)时间复杂度内,输出有序数据

2. __性能稳定__

散列表 扩容时 散列冲突时 耗时多性能不稳定,工程中的平衡二叉树性能稳定O(logn)

3. __查找时间__

尽管散列表查找的时间复杂度为常量级,但由于哈希冲突,常量不一定比logn小,再加上哈希函数耗时

4. __结构简单__

散列表结构复杂,需要考虑 散列函数设计 冲突解决 扩容 缩容.平衡二叉树只需考虑平衡性,已有成熟方案

5. __储存空间__

散列冲突的装载因子不能太多,不然浪费空间
