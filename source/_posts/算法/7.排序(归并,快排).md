---
title: 排序(归并,快排)
date: 2021-08-18 12:28:17
tags: 
    - 算法
---

# 排序(归并,快排)

归并排序 和 快速排序 都用到了 分治思想,

时间复杂度都为 O(nlogn)


## 归并排序(mergeSort)

分析出递推公式，找到终止条件
```js

// 这里将mergeArr函数执行成多层嵌套,
// 直到数组被拆分为只有0或1个元素的多个数组,类似金字塔的结构
// 然后 自下而上 开始层层执行mergeArr进行排序合并,直到金字塔顶端合二为一
// 最底层 排序合并 为 具有1或2个(0+1或1+1)元素的数组,
// 之后作为参数推送给倒数第二层的mergeArr,执行
// 合并为具有3或4个(1+2或2+2)元素的数组,
// 继续作为参数推送给倒数第三层的mergeArr
const mergeSort = (arr) => { // 递归分解函数
    // 终止条件:当任意数组分解到只有一个时返回。
    if (arr.length <= 1) return arr
    const middle = Math.floor(arr.length / 2) // 找到中间值
    const left = arr.slice(0, middle) // 分割数组
    const right = arr.slice(middle)
    // mergeSort进行递归分解,嵌套调用mergeArr,
    // mergeArr 多层执行,排序合并
    // 每一层mergeArr执行结束代表一半的数组合并完成,传递给上一层
    // 直到只剩一个数组
    return mergeArr(mergeSort(left), mergeSort(right))
}

// 对传入的 l数组 r数组 从左往右进行比较
// 由于是多次二等份 最底层的的l数组和r数组
// 必然是仅含1个元素或0个元素(传入数组为奇数时等分后会存在一个0元素数组)
// 创建一个新数组temp,第一次比较, 对比l与r 最左端的元素
// (由于l和r都是从底层1元素数组排序合并而来,所以都是左小右大的有序数组)
// 比较内的小的数据(l和r最左侧是各自最小的元素,比较内小者就是当前最小数据)
// push进新数组,并 当前侧index+1(相当于删除当前侧元素,剩下的继续比较)
// 第二次比较 继续取l和r最左端元素进行比较,小的那个push进temp(第二小元素)
// 第三次比较 继续取l和r最左端元素进行比较,小的那个push进temp(第三小元素)
// 直到,l或r其中一个数组的元素被取完,剩下另一个数组的元素必然是
// 有序(l和r本就有序且左小右大),且大于temp数组的,
// 直接拼接到temp数组最后,排序合并结束
const mergeArr = (left, right) => {// 合并子序列函数
    // 递推公式
    let temp = []
    let leftIndex = 0
    let rightIndex = 0
    // 判断2个数组中元素大小，依次插入数组 11 9
    while (left.length > leftIndex && right.length > rightIndex) {
        if (left[leftIndex] <= right[rightIndex]) {
            temp.push(left[leftIndex])
            leftIndex++
        } else {
            temp.push(right[rightIndex])
            rightIndex++
        }
    }
    // 合并 多余数组
    return temp.concat(left.slice(leftIndex)).concat(right.slice(rightIndex))
}

const testArr = []
let i = 0
while (i < 100) {
    testArr.push(Math.floor(Math.random() * 1000))
    i++
}
console.log('排序前:',testArr)
const res = mergeSort(testArr)
console.log('排序后:',res)
```

__稳定的排序算法__
`mergeArr()`递归分解函数中:
`left[leftIndex] <= right[rightIndex]`中的等号
`temp.concat(left.slice(leftIndex)).concat(right.slice(rightIndex))`
中的temp与concat顺序,left.concat与right的顺序
保证了 归并排序 是 稳定的排序

__时间复杂度:O(nlogn)__
公式推演太复杂,高中和大学的基本忘了.
自己想了一个思路,

__空间复杂度:O(n)__

归并排序 没有 快排 应用广泛,因为 __归并排序不是原地排序算法__

合并两个 有序数组 为一个 有序数组 时,需要借助额外的储存空间(temp数组)

但又由于合并完后,临时开辟的内存空间就会被释放,且CPU任意时刻只执行一个函数

所以,临时内存空间最大的时候也就是 n个数据的大小(最后一次合并时temp.length),

所以,O(n)

## 快速排序(quickSort)


```js
const swap = (arr, i, j) => {
    const temp = arr[i]
    arr[i] = arr[j]
    arr[j] = temp
}

// 获取 pivot 交换完后的index
const partition = (arr, pivot, left, right) => {
    const pivotVal = arr[pivot]
    let startIndex = left
    for (let i = left; i < right; i++) {
        if (arr[i] < pivotVal) {
            swap(arr, i, startIndex)
            startIndex++
        }
    }
    swap(arr, startIndex, pivot)
    return startIndex
}

const quickSort = (arr, left, right) => {
    if (left < right) {
        let pivot = right
        let partitionIndex = partition(arr, pivot, left, right)
        quickSort(arr, left, partitionIndex - 1 < left ? left : partitionIndex - 1)
        quickSort(arr, partitionIndex + 1 > right ? right : partitionIndex + 1, right)
    }

}


const testArr = []
let i = 0
while (i < 10) {
    testArr.push(Math.floor(Math.random() * 1000))
    i++
}
console.log('unsort', testArr)
quickSort(testArr, 0, testArr.length - 1);
console.log('sort', testArr)
```