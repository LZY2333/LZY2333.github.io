---
title: 2.ng-模板
date: 2021-03-17 20:55:38
tags: 
    - Angular
---

# 模板

## 简介

通过在模板中使用 Angular 的特有语法,增强HTML的功能.

Angular不支持模板中使用 script 标签。
Angular 会忽略 script标签，并向浏览器控制台输出一条警告

## `{{...}}` 插值及内部的模板表达式

Component 元数据中的 interpolation 属性可配置分隔符代替 `{{...}}`

里面 可写 表达式 ，可直接调用宿主组件的函数

表达式最终都会被转换为 字符串`(.toString())`

看上去是将结果插入元素标签之间， 其实插值只是特殊语法，Angular会将其转换为 赋值 的方式

__模板表达式的特点__

模板表达式中 不能使用 会引发副作用的JS表达式，如下:
赋值`(=,+=,-=...)`
new、typeof、instanceof等运算符
使用;或者,串联起来的表达式
`++` 和 `--` 自增自减
一些ES6 的运算符

不支持位运算,如 `|` 和 `&`
angular新出了一些模板表达式运算符,如 `|`,`?`和`!`

> 模板表达式不能引用全局命名空间中的任何东西，比如 window 或 document。
> 它们也不能调用 console.log 或 Math.max。 它们只能引用表达式上下文中的成员。

__模板表达式的上下文__

1. 组件实例中的属性或方法
2. 模板中的上下文属性,如模板输入变量
3. 模板引用变量,如#customerInput

```html
// 2
<ul>
  <li *ngFor="let customer of customers">{{customer.name}}</li>
</ul>
// 3
<label>Type something:
  <input #customerInput>{{customerInput.value}}
</label>
```

其中优先级 模板变量 > 指令的上下文属性 > 组件实例的成员变量

表达式的使用须遵循, 简单, 执行快速, 无可见副作用 的原则

## 模板语句

在 HTML 中用于响应用户事件的方法或属性

`<button (click)="deleteHero()">Delete hero</button>`

与模板表达式差不多,但 模板语句 的解析器 与 模板表达式不同 , 并且支持 基本赋值= 和 带;的串联表达式

不能使用: new 自增自减 赋值运算符`+=/-=` 按位运算符`|`和`&` 管道操作符`|`

__模板语句的上下文__

与模板表达式的上下文一致,模板变量,指定的上下文属性,组件实例的变量成员,还能接收事件$event

## 管道

使用 管道 格式化数据, 如格式化 金额日期.

管道可配置参数 `{{ amount | currency:'EUR':'Euros '}}` ,参数也可为变量

可串联配置多个管道 `{{  birthday | date:'fullDate' | uppercase}}`

__常见管道__

DatePipe：根据本地环境中的规则格式化日期值。

UpperCasePipe：把文本全部转换成大写。

LowerCasePipe ：把文本全部转换成小写。

CurrencyPipe ：把数字转换成货币字符串，根据本地环境中的规则进行格式化。

DecimalPipe：把数字转换成带小数点的字符串，根据本地环境中的规则进行格式化。

PercentPipe ：把数字转换成百分比字符串，根据本地环境中的规则进行格式化。


__自定义一个管道__

管道类名 大驼峰, name 小驼峰,不能使用连字符,
使用前记得加入到NgModule元数据的 declarations 属性中声明
Angular CLI 的 ng generate pipe 命令会自动注册该管道

自定义管道,管道前 被绑定的值会作为第一个参数, 管道的参数 会从作为第二个参数开始
```js
//实现一种指数级转换，以指数级增加英雄的力量,基本值2,通过管道设定指数级为10,最终展示1024
import { Pipe, PipeTransform } from '@angular/core';
@Pipe({name: 'exponentialStrength'})
export class ExponentialStrengthPipe implements PipeTransform {
  transform(value: number, exponent?: number): number {
    return Math.pow(value, isNaN(exponent) ? 1 : exponent);
  }
}
```
```js
import { Component } from '@angular/core';
@Component({
  selector: 'app-power-booster',
  template: `
    <h2>Power Booster</h2>
    <p>Super power boost: {{2 | exponentialStrength: 10}}</p>
  `
})// 1024
export class PowerBoosterComponent { }
```

__通过管道的数据绑定特性来响应用户操作__

Angular 会检测每次变更，并立即运行管道

```js
import { Component } from '@angular/core';

@Component({
  selector: 'app-power-boost-calculator',
  template: `
    <h2>Power Boost Calculator</h2>
    <div>Normal power: <input [(ngModel)]="power"></div>
    <div>Boost factor: <input [(ngModel)]="factor"></div>
    <p>
      Super Hero Power: {{power | exponentialStrength: factor}}
    </p>
  `
})
export class PowerBoostCalculatorComponent {
  power = 5;
  factor = 1;
} // input框修改,都会影响变量power或factor,展示的值都会重新计算
```

变更检测的原理







## NgModule 模块

@NgModule修饰的class 就是一个NgModule

@NgModule 使用一个元数据对象来告诉Angular如何去编译和运行代码。

一个模块内部可以包含组件、指令、管道，并且可以将它们的访问权限声明为公有，以使外部模块的组件可以访问和使用到它们。

1. declarations 声明模块 内部 的 Components/Directives/Pipes

2. imports 声明导入 外部 模块暴露的 Components/Directives/Pipes
   
3. providers 声明指定应用程序的根级别需要使用的service

4. exports 声明可暴露给外部使用的内部成员

5. bootstrap 声明app启动的根组件,该组件会被自动放入entryComponents中

6. entryCompoenents 声明不会再模板中被引用的组件.一般是ng自己使用,ng会自动把bootstrap、路由组件放入其中。

> 2.imports, 如导入CommonModule后就可以使用NgIf、NgFor等指令。
> 3.providers,模块中providers的service会是单例模式,每种service,项目中所有组件公用一个service实例
>   从angular6开始,只要使用angular-cli的命令创建service,会默认单例,service中默认增加语句`@Injectable({ providedIn: 'root', })`.
> 4.exports,导入另一个模块时,只会导入被导入模块的 exports 内声明的成员.

__功能模块__

根模块的目的在于启动app，功能模块的目的在于扩展app

功能模块可以根据需要暴露或隐藏具体的实现,或是延迟加载

```js

import { ModuleWithProviders }  from '@angular/core';
import { Routes, RouterModule } from '@angular/router';
 
export const routes: Routes = [
  { path: '', redirectTo: 'contact', pathMatch: 'full'},
  { path: 'crisis', loadChildren: 'app/crisis/crisis.module#CrisisModule' },
  { path: 'heroes', loadChildren: 'app/hero/hero.module#HeroModule' }
];

export const routing: ModuleWithProviders = RouterModule.forRoot(routes);
```
path指明路径，loadChildren指明使用延迟加载，'app/crisis/crisis.module#CrisisModule'指明了模块的路径，和模块的名称。