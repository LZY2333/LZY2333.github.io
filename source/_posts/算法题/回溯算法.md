---
title: 回溯算法
date: 2023-10-24 20:49:27
categories: 技术栈
tags: 
    - 算法题
---

## 回溯算法

本质上是遍历所有的解，为了能遍历到所有的解，将求解分为多个阶段，
每个阶段先随便找条路走，发现路走不通的时候，在换一种走法走，当所有路都走完，
再返回上一阶段继续遍历路径，这样遍历完所有的解。

本质是穷举，很多问题只能暴力搜索，甚至暴力搜索都写不出来，这时候要回溯算法来暴力搜索

组合问题：N个数里面按一定规则找出k个数的集合
切割问题：一个字符串按一定规则有几种切割方式
子集问题：一个N个数的集合里有多少符合条件的子集
排列问题：N个数按一定规则全排列，有几种排列方式
棋盘问题：N皇后，解数独等等

1. 思考暴力穷举是怎么解的
2. 每一轮从哪开始(参数)，在哪结束(结束条件)
3. 每一轮如何遍历(循环)

新增参数为一般为当前的进度

剪枝可以放在循环内，也可以放在结束条件内

```js
void backtracking(参数) {
    if (终止条件) {
        存放结果;
        return;
    }

    for (选择：本层集合中元素（树中节点孩子的数量就是集合的大小）) {
        处理节点;
        backtracking(路径，选择列表); // 递归
        回溯，撤销处理结果
    }
}
```

### 八皇后问题

92个解
```js
const result = new Array(8).fill(-1) // key表示行，value表示列

const cal8queens = (row) => {
    if (row === 8) {
        printQueens(result)
        return
    }
    for (let column = 0; column < 8; column++) {
        if (isOK(row, column)) {
            result[row] = column
            cal8queens(row + 1)
        }
    }
    
}
const isOK = (row, column) => {
    let leftUp = rightUp = column
    for (let i = row - 1; i >= 0; i--) { // 逐行往上考察每一行
        leftUp--
        rightUp++
        if (result[i] === column) return false // 竖行有重合
        if (leftUp >= 0 && result[i] === leftUp) return false // 左上有重合
        if (rightUp < 8 && result[i] === rightUp) return false // 右上有重合
    }
    return true
}
const printQueens = (result) => {
    const a = new Array(8).fill(0).map(() => new Array(8).fill(0))
    result.forEach((column, row) => {
        a[row][column] = 1
    });
    console.log(result)
    // console.log(a)
}

cal8queens(0)
```

## 77. 组合

https://leetcode.cn/problems/combinations/description/

给定两个整数 n 和 k，返回范围 [1, n] 中所有可能的 k 个数的组合。

```js
// 1. 思考暴力穷举是怎么解的
// 2. 每一轮从哪开始(参数)，新增参数为当前的进度，在哪结束(结束条件)
// 3. 每一轮如何遍历
let result = []
const path = []
var combine = function (n, k) {
    result = []
    combineHelper(n, k, 1)
    return result
};
const combineHelper = (n, k, startIndex) => {
    if (path.length === k) {
        result.push([...path])
        return
    }
    for (let i = startIndex; i <= n; i++) {
        path.push(i)
        combineHelper(n, k, i + 1)
        path.pop() // 回溯
    }
}
console.log(combine(4, 2));
[[1, 2], [1, 3], [1, 4], [2, 3], [2, 4], [3, 4]]
```

剪枝优化
```js
// 遍历对象为 [1,2,3,4]， k 为 2
// 1. "i <= n"    : 需要 =号, 因为是从1到4, n为4
// 2. "(k - path.length - 1)" : 目的是填满k，末端的"枝" 和 "叶" 才解锁 k到n的项
// 3. "k-1": 前端的"枝",比如path还为空时，需要遍历到3，想遍历到3 k就得-1
// 3. 因为path想拿到k个数，起始的"枝"必须遍历到后k个数的第一个数，所以k得-1
for (let i = startIndex; i <= n - (k - path.length - 1); ++i) {
    ...
}
```

暴力穷举是怎么解的
```js
// 假设 combine(4, 2),那result 就是 12 13 14 23 24 34
// k就是k重循环，先放i，再放j
let result = []
let path = []
for (let i = 1; i <= n; i++) {
    path = [].push(i)
    for (let j = i + 1; j <= n; j++) {
        path.push(j)
    }
    result.push(path)
}
```

### 216. 组合总和 III

https://leetcode.cn/problems/combination-sum-iii/description/

```js
let result = []
const path = []
var combinationSum3 = function (k, n) {
    result = []
    sumHelper(k, n, 1, 0)
    return result
};
// 新增参数用于表示当前的进度
const sumHelper = (k, n, startIndex, sum) => {
    if (path.length === k) {
        sum === n && result.push([...path])
        return
    }

    for (let i = startIndex; i <= 9 - (k - path.length - 1) && sum + i <= n; i++) {
        path.push(i)
        sumHelper(k, n, i + 1, sum + i)
        path.pop()
    }
}
console.log(combinationSum3(3, 7));
[[1, 2, 4]]
```

### 17. 电话号码的字母组合

https://leetcode.cn/problems/letter-combinations-of-a-phone-number/description/

```js
var letterCombinations = function (digits) {
    if (!digits) return []
    const map = ["", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"]
    const result = [], path = []
    backTracking(0)
    function backTracking(index) {
        if (index === digits.length) {
            result.push(path.join(''))
            return
        }
        for (const chart of map[digits[index]]) {
            path.push(chart)
            backTracking(index + 1)
            path.pop()
        }
    }
    return result
};
console.log(letterCombinations('23'));
[ 'ad', 'ae', 'af', 'bd', 'be', 'bf', 'cd', 'ce', 'cf' ]
```

### 39. 组合总和

假设这里求的是数量而不是打印遍历，则同 518. 零钱兑换 II，使用动态规划
```js
// 前面的选择影响后面的选择，无限次选取，完全背包问题
var combinationSum = function (candidates, target) {
    // dp[i] 代表能组成 i 的组合candidates全部组合数
    const dp = new Array(target + 1).fill(0)
    // 要组成总和0, 有1种方式
    dp[0] = 1
    // 针对每一个item遍历容量j
    for (let i = 0; i < candidates.length; i++) {
        // 可无限次选取i，完全背包问题，顺序遍历
        for (let j = candidates[i]; j <= target; j++) {
            // 如果 candidates[j] 放入后，剩余空间有可填充的dp，那就放入
            dp[j] = dp[j] + dp[j - candidates[i]]
        }
    }
    return dp[target]
};

console.log(combinationSum([2,3,6,7], 7))
// 输出2,两种:[[2,2,3],[7]]
2 [ 1, 0, 1, 0, 1, 0, 1, 0 ]
3 [ 1, 0, 1, 1, 1, 1, 2, 1 ]
6 [ 1, 0, 1, 1, 1, 1, 3, 1 ]
7 [ 1, 0, 1, 1, 1, 1, 3, 2 ]
```