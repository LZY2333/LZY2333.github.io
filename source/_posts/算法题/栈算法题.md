---
title: 栈算法题
date: 2021-10-18 11:16:42
tags: 
    - 算法题
---

# 栈算法题

## 有效的括号（ LeetCode 20 ）

[leetcode](https://leetcode-cn.com/problems/valid-parentheses/)

```js
var isValid = function(s) {
    if(s.length % 2 === 1) return false
    let stack = []
    let temp = s.split('')
    const map = {
        ')':'(',
        '}':'{',
        ']':'[',
    }
    for(let i = 0; i < temp.length; i++) {
        if(temp[i] === '(' || temp[i] === '{' || temp[i] === '[' ) {
            stack.push(temp[i])
        } else {
            if(stack[stack.length - 1] === map[temp[i]]) {
                stack.pop()
            } else {
                return false
            }
        }
    }
    return !stack.length
};
```

## 基本计算器（ LeetCode 224 ）

[leetcode](https://leetcode-cn.com/problems/basic-calculator/submissions/)

```js
var calculate = function(s) {
    let stack = [1] // 用来记住每一层括号的正负号
    let currentSign = 1
    let result = 0
    let i = 0
    while(i < s.length) {
        if(s[i] === ' ') {
            i++;
        } else if(s[i] === '+') {
            currentSign = +stack[stack.length-1]
            i++
        } else if(s[i] === '-') {
            currentSign = -stack[stack.length-1]
            i++
        } else if(s[i] === '(') { // 遇见括号就把 括号内数字解括号后 的正负记录下来
            stack.push(currentSign) // 内层还有括号的话,跳出后还用
            i++
        } else if(s[i] === ')') { // 括号只起反转正负的作用,未按括号的顺序去计算
            stack.pop()
            i++
        } else { // 数字,发现了数字就往后找一串数字
            let number  = ''
            while(i < s.length && !isNaN(s[i]) && s[i] !==' ') {
                number = number + s[i]
                i++
            }
            result = result + currentSign*number
        }
    }
    return result
};
```

### 自己的解法

未考虑数字大于10的

括号内用了递归

```js
var calculate = function(s) {
    let temp = s.replace(/\s+/g,"").split('')
    return compute(temp)
};

var compute = function(temp) {
    let stack = []

    for(let i = 0; i < temp.length; i++) {
        if(temp[i] === '(') { // 如果是左括号，就拿到左括号和右括号间的内容，递归
            let temp1 = []
            let btacketCount = 1
            for(i = i + 1;i < temp.length; i ++) { // 直接用i计算，从'('下一位开始
                if(temp[i] === ')') btacketCount-- // 碰见')' 就减1
                if(temp[i] === '(') btacketCount++
                if(btacketCount === 0) break
                temp1.push(temp[i])
            }
            const result = compute(temp1)
            if(stack.length) {
                const operator = stack.pop() // 拿到栈顶运算符
                if(operator === '+') {
                    stack[stack.length - 1] = +stack[stack.length - 1] + +result
                } else if(operator === '-') {
                    stack[stack.length - 1] = +stack[stack.length - 1] - +result
                }
            } else {
                stack.push(+result)
            }
            continue; // 开始计算下一个,此时i指向')'
        }

        if(temp[i] === '+'|| temp[i] === '-') { // 如果是计算符号，直接push
            stack.push(temp[i])
            continue;
        }
        if(!isNaN(temp[i]) && stack.length) { // 如果是数字,并且栈顶有元素(此元素必然是符号+-)
            const operator = stack.pop() // 拿到栈顶运算符
            if(operator === '+') {
                stack[stack.length - 1] = +stack[stack.length - 1] + +temp[i]
            } else if(operator === '-') {
                stack[stack.length - 1] = +stack[stack.length - 1] - +temp[i]
            }
        } else {
            stack.push(temp[i])
        }
    }
    return stack.pop()
}
```

## 最小栈（ LeetCode 155 ）

注意这里给的是TS,同时注意,标答能保证时间复杂度为O(1)

```ts
class MinStack {
    protected Stack:number[] = [];
    protected MinStack:number[] = [];

    push(val: number): void {
        this.Stack.push(val);
        this.MinStack.push(Math.min(val, this.getMin() ?? Infinity));
    }
    // ?? 前面的值为 null undefined 则取后面的值

    pop(): void {
        this.Stack.pop();
        this.MinStack.pop();
    // 每次给Stack放数,都会给MinStack放一次前n个最小的数,所以pop两个同时pop没事.
    // MinStack每个数都是对应Stack位置的前N个数中最小的数.
    }

    top(): number {
        return this.Stack[this.Stack.length - 1];
    }

    getMin(): number {
        return this.MinStack[this.MinStack.length - 1];
    }
}
```

### 自己的解法

写题时暴露的问题:
min 忘了赋初始值,且应为this.stack[0]
忘了写this,stack拼写错误
时间复杂度为O(n)
```js
var MinStack = function() {
    this.stack = []
};

MinStack.prototype.push = function(val) {
    this.stack.push(val)
};

MinStack.prototype.pop = function() {
    return this.stack.pop()
};

MinStack.prototype.top = function() {
    return this.stack.length ? this.stack[this.stack.length -1] : null
};

MinStack.prototype.getMin = function() {
    let min = this.stack[0] ? this.stack[0] : null
    for(let i=0;i<this.stack.length;i++) {
        if(this.stack[i] < min) min = this.stack[i]
    }
    return min
};
```

## 验证栈序列（ LeetCode 946 ）