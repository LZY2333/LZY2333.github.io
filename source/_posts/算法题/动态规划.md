
---
title: 动态规划算法题
date: 2023-10-16 21:29:30
categories: 技术栈
tags: 
    - 算法题
---

## 动态规划

动态规划适用于每一步都会影响后续的情况,

或者说 每一个状态一定是由上一个状态推导出来, 某一问题有很多重叠子问题,本质是遍历

一点就区分于贪心，贪心没有状态推导，而是从局部直接选最优的

1. 确定dp数组含义
2. 确定递推公式
3. 确定dp初始值
4. 确定遍历顺序
5. 举例推导dp数组

### 509. 斐波那契数

https://leetcode.cn/problems/fibonacci-number/

```js
var fib = function(n) {
    if(n === 0 || n === 1) return n
    const dp = [0,1]
    for(let i = 2; i <= n; i++) {
        dp[i] = dp[i-1] + dp[i-2]
    }
    return dp[n]
};
```

### 70. 爬楼梯
https://leetcode.cn/problems/climbing-stairs/

```js
var climbStairs = function (n) {
    // 1. 确定DP数组含义，下标含义: 达到第i阶有dp[i]种方法
    // 2. 确定递推公式: dp[i] = dp[i-2] + dp[i-1]
    // 3. dp[0] = 1 (没有0台阶,n为正整数，为了满足规律，赋值个1,其实没用到)
    //    dp[1] = 1 dp[2] = 2
    if (n === 1 || n === 2) return n
    const dp = [1, 1, 2]
    for (let i = 3; i <= n; i++) {
        dp[i] = dp[i - 2] + dp[i - 1]
    }
    return dp[n]
};
```

### 746. 使用最小花费爬楼梯
https://leetcode.cn/problems/min-cost-climbing-stairs/

```js
var minCostClimbingStairs = function(cost) {
    // 1. 确定DP数组含义，下标含义: 达到第i阶最少要dp[i]个体力
    // 2. 确定递推公式: dp[i] = dp[i-2] + const[i-2] 或
    //                dp[i] = dp[i-1] + const[i-1] 中的 minor
    // 3. 确定初始状态: dp[0] = 0 dp[1] = 0 (可以从0或1开始)
    const dp = [0,0]
    for(let i = 2; i <= cost.length; i++) {
        dp[i] = Math.min(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2])
    }
    return dp[cost.length]
};
// 优化空间复杂度，因为dp[i]就是由前两位推出来的，那么也不用dp数组了
var minCostClimbingStairs = function(cost) {
    let before = after = 0
    for(let i = 2; i <= cost.length; i++) {
        const now =  Math.min(after + cost[i-1], before + cost[i-2])
        before = after
        after = now
    }
    return after
};
```

### 62. 不同路径

https://leetcode.cn/problems/unique-paths/description/

```js
var uniquePaths = function (m, n) {
    // dp[i][j] 到达 i j 有多少种走法，抛弃0 0，从 1 1 开始
    // dp[i][j] = dp[i-1][j] + dp[i][j-1],要走到ij,必须走到i-1 或 j-1。
    // 从[1,1] 走到 [m,n] 需要初始化第一行及第一列为1
    const dp = new Array(m + 1).fill(0).map(() => new Array(n + 1).fill(1))
    for (let i = 2; i <= m; i++) {
        for (let j = 2; j <= n; j++) {
            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
        }
    }

    return dp[m][n]
};

// 简化到一维，不是很懂
var uniquePaths = function (m, n) {
    const dp = new Array(n).fill(1)
    for (let j = 1; j < m; j++) {
        for (let i = 1; i < n; i++) {
            dp[i] += dp[i - 1];
        }
    }
    return dp[n - 1];
};
```

### 63. 不同路径 II

https://leetcode.cn/problems/unique-paths/solutions/856968/dai-ma-sui-xiang-lu-dong-gui-wu-bu-qu-xi-1vkb/

```js
var uniquePathsWithObstacles = function (obstacleGrid) {
    const h = obstacleGrid.length, l = obstacleGrid[0].length
    // 初始化时，第一列 或 第一排，假设前面有障碍物，后面都是0
    // 先初始化为0，然后赋值1
    const dp = new Array(h).fill(0).map(() => new Array(l).fill(0))
    for (let i = 0; i < h && obstacleGrid[i][0] === 0; i++) dp[i][0] = 1
    for (let i = 0; i < l && obstacleGrid[0][i] === 0; i++) dp[0][i] = 1

    for (let i = 1; i < h; i++) {
        for (let j = 1; j < l; j++) {
            if (obstacleGrid[i][j]) {
                dp[i][j] = 0
                continue
            }
            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
        }
    }
    return dp[h - 1][l - 1]
};
```

### 343. 整数拆分
https://leetcode.cn/problems/integer-break/description/

```js
// 首先分析题目，上一步的选择影响当前步，动态规划
var integerBreak = function (n) {
    // dp[i] 拆分 i 能得到的最大乘积，i 从 0 到 n
    // dp[i] = 遍历到j时，j是必拆。此时存在两种情况
    //         j * (i - j) 剩余的数不拆；  j * dp[i - j] 剩余的数也拆(j*剩余数拆的最大值)
    //        最后，dp[i]得是 j 遍历的循环中的最大值，所以 是三者取最大
    // dp[0]无意义 dp[1]无意义 均无法拆分 dp[2] = 1，其他得赋值0
    let dp = new Array(n + 1).fill(0) // n+1是因为得多算一个0最后才会有dp[n]
    dp[2] = 1
    for (let i = 3; i <= n; i++) {
        // 对于每个i，遍历其 先拆出j能得的最大值，遍历完j后得到当前i能拆出的最大乘积
        // 至少拆出两个数，两个数遍历到拆一半的时候肯定是最大的，
        // 进一步假设是拆出三个数，那应该遍历到1/3就行，到1/2肯定够
        // 所以j <= i / 2
        for (let j = 1; j <= i / 2; j++) {
            dp[i] = Math.max(j * (i - j), j * dp[i - j], dp[i])
        }
    }
    return dp[n]
};
// 问题来了，什么时候要一重循环，什么时候要二重循环？
// 那就是内部得多遍历一层，内部可能两种情况，三种情况，k种情况
// 这k种情况也依赖上一次的选择，总体有点像动态规划里再动态规划
```

### 96. 不同的二叉搜索树

https://leetcode.cn/problems/unique-binary-search-trees/description/

```js


```

### ------买卖股票------

### 121.买卖股票的最佳时机

https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/
```js
var maxProfit = function (prices) {
    // 只能买卖一次，假设昨天是卖出的状态，那今天再买入就只有-prices[i],
    const l = prices.length
    const dp = new Array(l).fill(0).map(() => new Array(2).fill(0))

    dp[0][1] = -prices[0]
    dp[0][0] = 0

    for (let i = 1; i < l; i++) {
        dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i])
        dp[i][1] = Math.max(dp[i - 1][1], -prices[i])
    }
    return dp[l - 1][0]
};

// maxProfit([7, 1, 5, 3, 6, 4])
// dp: [[-7, 0], [-1, 0], [-1, 4], [-1, 4], [-1, 5], [-1, 5]]
```

### 122. 买卖股票的最佳时机 II

https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/

```js
var maxProfit = function(prices) {
    const l = prices.length
    const dp = new Array(l).fill(0).map(() => new Array(2).fill(0))
    dp[0][0] = 0
    dp[0][1] = -prices[0]
    for(let i = 1; i < prices.length; i++) {
        dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i])
        dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0] - prices[i])
    }
    return dp[l-1][0]
};
```

### 714. 买卖股票的最佳时机含手续费

https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/

```js
var maxProfit = function (prices, fee) {
    const l = prices.length
    const dp = new Array(l).fill(0).map(() => new Array(2).fill(0))

    dp[0][0] = 0
    dp[0][1] = -prices[0] - fee
    for (let i = 1; i < l; i++) {
        dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i])
        dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i] - fee)
    }

    return dp[l - 1][0]
};
```


### ------背包问题------
01背包、完全背包、多重背包、分组背包和混合背包

一个商品如果可以重复多次放入是完全背包，而只能放入一次是01背包

第一层遍历物品，第二层遍历背包容量

假设旅行者的背包最多装1800件圣遗物，现有双爆评分记为[C1，C2，C3....Cn]的n件圣遗物需要装进背包，求旅行者能留下的圣遗物最大价值

### 416. 分割等和子集(01背包)

https://leetcode.cn/problems/partition-equal-subset-sum/description/

698.划分为k个相等的子集
473.火柴拼正方形

```js
var canPartition = function (nums) {
    const l = nums.length
    if(nums.length < 2) return false
    const sum = nums.reduce((pre, cur) => pre + cur, 0)
    if (sum % 2 !== 0) return false
    const capacity = sum / 2
    // dp[i][j] 代表前i个元素能否组成和为j的结果
    // [1, 5, 11, 5]
    const dp = new Array(l).fill(0).map(() => new Array(capacity).fill(false))

    // 第0项 满足 容量为nums[0]的背包
    dp[0][nums[0]] = true

    // 一步步扩大可选放入背包的物品范围，每片i轮询可理解为，i-1项中加入此i项能否满足容量j
    for (let i = 1; i < l; i++) {
        // 该层for循环，相当于遍历出了，前i项，能组合出来哪些容量。
        for (let j = 0; j <= capacity; j++) {
            // 对每新增的第i项进行容量遍历，判断 第i项 能不能放入 容量j 的背包，
            // 1. 如果 nums[i]  > 容量j 太大不能放入背包，那容量dp[i][j] 沿用之前 dp[i-1][j]的结果(可能i-1项可以满足 容量j，也算)
            // 2. 如果 nums[i] <= 容量j 那就有两种情况，
            // 情况1 第i项 放入， 那剩余的空间 j - nums[i]，看看dp[i-1]中是否能恰好填充，即dp[i-1][j - nums[i]]是否为true
            // 情况2 第i项 不放入， 那沿用 dp[i-1][j] 的结果(前i-1项能满足和为容量j也行)
            // 二者有一个成功即为true
            // 在遍历的过程中，已经考虑了背包容量 为 0 到 j 的所有情况
            if (nums[i] > j) {
                dp[i][j] = dp[i - 1][j]
            } else if (nums[i] < j) {
                // 也可理解为，i-1项能满足容量j也行，i-1项不能满足容量j的话就把 第i项 放入背包，看看i-1项，能不能满足剩余空间。
                dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i]]
            } else {
                dp[i][j] = true
            }
        }
        console.log(i,nums[i],dp[i])
    }
    // dp[l-1][capacity] 代表 用上nums所有元素(l-1),能否组合出容量capacity
    return dp[l - 1][capacity]
};

canPartition([1,5,11,5])
```

```js
// 滚动数组,由于每次的数据只依赖于上一层i-1的数据，所以可以直接在当前一维数组比
var canPartition = function(nums) {
    const sum = (nums.reduce((p, v) => p + v));
    if (sum & 1) return false;
    const dp = Array(sum / 2 + 1).fill(0);
    for(let i = 0; i < nums.length; i++) {
        // 容量j >= nums[i]代表当前i在这个容量都是有选择的，可放进去的
        for(let j = sum / 2; j >= nums[i]; j--) {
            // 假设 [1,5,11,5]
            // 第一轮就是 1 能放进容量 11，并与0比谁大。一轮下来就是[0,1,1,1,...]
            // 第二轮就是 5 能放进容量 11 到 0 的话， value加上 并且剩余质量能否补上，并与1比大
            dp[j] = Math.max(dp[j], dp[j - nums[i]] + nums[i]);
            if (dp[j] === sum / 2) {
                return true;
            }
        }
    }
    return dp[sum / 2] === sum / 2;
};

canPartition([1,5,11,5])
0 1  [ 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ]
1 5  [ 0, 1, 1, 1, 1, 5, 6, 6, 6, 6, 6, 6 ]
2 11 [ 0, 1, 1, 1, 1, 5, 6, 6, 6, 6, 6, 11 ]
3 5  [ 0, 1, 1, 1, 1, 5, 6, 6, 6, 6, 10, 11 ]
```

### 1049. 最后一块石头的重量 II(01背包)

https://leetcode.cn/problems/last-stone-weight-ii/description/

```js
// 前面的选择影响后面的选择，动态规划
var lastStoneWeightII = function (stones) {
    // 这题本质是找到尽可能接近 sum/2 的组，也即 背包的 value/容量 最大 为 sum/2。
    // dp[j]: 前j项最大价值为dp[j]
    // 总容量j 减去当前j的容量，剩余的容量的价值， 加上当前j的价值；与上一次ap[j]比出最大值
    // dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
    const l = stones.length
    if (l < 2) return stones[0]
    const sum = stones.reduce((p, c) => p + c)
    const maxCapacity = Math.ceil(sum / 2)
    const dp = new Array(maxCapacity + 1).fill(0)
    for (let i = 0; i < l; i++) {
        // 在前几次的遍历中，后面的j基本无意义，因为肯定会被覆盖，后续遍历中i物品变多，更能撑满背包
        for (let j = maxCapacity; j >= stones[i]; j--) {
            dp[j] = Math.max(dp[j], dp[j - stones[i]] + stones[i])
        }
        // console.log(i,stones[i],dp)
    }
    return Math.abs(dp[maxCapacity] * 2 - sum)
};

lastStoneWeightII([2,7,4,1,8,1])
```

### 494. 目标和(01背包,组合)

https://leetcode.cn/problems/target-sum/