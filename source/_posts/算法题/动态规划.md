
---
title: 动态规划算法题
date: 2023-10-16 21:29:30
categories: 技术栈
tags: 
    - 算法题
---

## 动态规划

动态规划适用于每一步都会影响后续的情况,

或者说 每一个状态一定是由上一个状态推导出来, 某一问题有很多重叠子问题,本质是遍历

一点就区分于贪心，贪心没有状态推导，而是从局部直接选最优的

1. 确定dp数组含义
2. 确定递推公式
3. 确定dp初始值
4. 确定遍历顺序
5. 举例推导dp数组

### 509. 斐波那契数

https://leetcode.cn/problems/fibonacci-number/

```js
var fib = function(n) {
    if(n === 0 || n === 1) return n
    const dp = [0,1]
    for(let i = 2; i <= n; i++) {
        dp[i] = dp[i-1] + dp[i-2]
    }
    return dp[n]
};
```

### 70. 爬楼梯
https://leetcode.cn/problems/climbing-stairs/

```js
var climbStairs = function (n) {
    // 1. 确定DP数组含义，下标含义: 达到第i阶有dp[i]种方法
    // 2. 确定递推公式: dp[i] = dp[i-2] + dp[i-1]
    // 3. dp[0] = 1 (没有0台阶,n为正整数，为了满足规律，赋值个1,其实没用到)
    //    dp[1] = 1 dp[2] = 2
    if (n === 1 || n === 2) return n
    const dp = [1, 1, 2]
    for (let i = 3; i <= n; i++) {
        dp[i] = dp[i - 2] + dp[i - 1]
    }
    return dp[n]
};
```

### 746. 使用最小花费爬楼梯
https://leetcode.cn/problems/min-cost-climbing-stairs/

```js
var minCostClimbingStairs = function(cost) {
    // 1. 确定DP数组含义，下标含义: 达到第i阶最少要dp[i]个体力
    // 2. 确定递推公式: dp[i] = dp[i-2] + const[i-2] 或
    //                dp[i] = dp[i-1] + const[i-1] 中的 minor
    // 3. 确定初始状态: dp[0] = 0 dp[1] = 0 (可以从0或1开始)
    const dp = [0,0]
    for(let i = 2; i <= cost.length; i++) {
        dp[i] = Math.min(dp[i-1] + cost[i-1], dp[i-2] + cost[i-2])
    }
    return dp[cost.length]
};
// 优化空间复杂度，因为dp[i]就是由前两位推出来的，那么也不用dp数组了
var minCostClimbingStairs = function(cost) {
    let before = after = 0
    for(let i = 2; i <= cost.length; i++) {
        const now =  Math.min(after + cost[i-1], before + cost[i-2])
        before = after
        after = now
    }
    return after
};
```

### 62. 不同路径

https://leetcode.cn/problems/unique-paths/description/

```js
var uniquePaths = function (m, n) {
    // dp[i][j] 到达 i j 有多少种走法，抛弃0 0，从 1 1 开始
    // dp[i][j] = dp[i-1][j] + dp[i][j-1],要走到ij,必须走到i-1 或 j-1。
    // 从[1,1] 走到 [m,n] 需要初始化第一行及第一列为1
    const dp = new Array(m + 1).fill(0).map(() => new Array(n + 1).fill(1))
    for (let i = 2; i <= m; i++) {
        for (let j = 2; j <= n; j++) {
            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
        }
    }

    return dp[m][n]
};

// 简化到一维，不是很懂
var uniquePaths = function (m, n) {
    const dp = new Array(n).fill(1)
    for (let j = 1; j < m; j++) {
        for (let i = 1; i < n; i++) {
            dp[i] += dp[i - 1];
        }
    }
    return dp[n - 1];
};
```

### 63. 不同路径 II

https://leetcode.cn/problems/unique-paths/solutions/856968/dai-ma-sui-xiang-lu-dong-gui-wu-bu-qu-xi-1vkb/

```js
var uniquePathsWithObstacles = function (obstacleGrid) {
    const h = obstacleGrid.length, l = obstacleGrid[0].length
    // 初始化时，第一列 或 第一排，假设前面有障碍物，后面都是0
    // 先初始化为0，然后赋值1
    const dp = new Array(h).fill(0).map(() => new Array(l).fill(0))
    for (let i = 0; i < h && obstacleGrid[i][0] === 0; i++) dp[i][0] = 1
    for (let i = 0; i < l && obstacleGrid[0][i] === 0; i++) dp[0][i] = 1

    for (let i = 1; i < h; i++) {
        for (let j = 1; j < l; j++) {
            if (obstacleGrid[i][j]) {
                dp[i][j] = 0
                continue
            }
            dp[i][j] = dp[i - 1][j] + dp[i][j - 1]
        }
    }
    return dp[h - 1][l - 1]
};
```

### 343. 整数拆分
https://leetcode.cn/problems/integer-break/description/

```js
// 首先分析题目，上一步的选择影响当前步，动态规划
var integerBreak = function (n) {
    // dp[i] 拆分 i 能得到的最大乘积，i 从 0 到 n
    // dp[i] = 遍历到j时，j是必拆。此时存在两种情况
    //         j * (i - j) 剩余的数不拆；  j * dp[i - j] 剩余的数也拆(j*剩余数拆的最大值)
    //        最后，dp[i]得是 j 遍历的循环中的最大值，所以 是三者取最大
    // dp[0]无意义 dp[1]无意义 均无法拆分 dp[2] = 1，其他得赋值0
    let dp = new Array(n + 1).fill(0) // n+1是因为得多算一个0最后才会有dp[n]
    dp[2] = 1
    for (let i = 3; i <= n; i++) {
        // 对于每个i，遍历其 先拆出j能得的最大值，遍历完j后得到当前i能拆出的最大乘积
        // 至少拆出两个数，两个数遍历到拆一半的时候肯定是最大的，
        // 进一步假设是拆出三个数，那应该遍历到1/3就行，到1/2肯定够
        // 所以j <= i / 2
        for (let j = 1; j <= i / 2; j++) {
            dp[i] = Math.max(j * (i - j), j * dp[i - j], dp[i])
        }
    }
    return dp[n]
};
// 问题来了，什么时候要一重循环，什么时候要二重循环？
// 那就是内部得多遍历一层，内部可能两种情况，三种情况，k种情况
// 这k种情况也依赖上一次的选择，总体有点像动态规划里再动态规划
```

### 96. 不同的二叉搜索树

https://leetcode.cn/problems/unique-binary-search-trees/description/

```js


```

### ------买卖股票------

### 121.买卖股票的最佳时机

https://leetcode.cn/problems/best-time-to-buy-and-sell-stock/description/
```js
var maxProfit = function (prices) {
    // 只能买卖一次，假设昨天是卖出的状态，那今天再买入就只有-prices[i],
    const l = prices.length
    const dp = new Array(l).fill(0).map(() => new Array(2).fill(0))

    dp[0][1] = -prices[0]
    dp[0][0] = 0

    for (let i = 1; i < l; i++) {
        dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i])
        dp[i][1] = Math.max(dp[i - 1][1], -prices[i])
    }
    return dp[l - 1][0]
};

// maxProfit([7, 1, 5, 3, 6, 4])
// dp: [[-7, 0], [-1, 0], [-1, 4], [-1, 4], [-1, 5], [-1, 5]]
```

### 122. 买卖股票的最佳时机 II

https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-ii/

```js
var maxProfit = function(prices) {
    const l = prices.length
    const dp = new Array(l).fill(0).map(() => new Array(2).fill(0))
    dp[0][0] = 0
    dp[0][1] = -prices[0]
    for(let i = 1; i < prices.length; i++) {
        dp[i][0] = Math.max(dp[i-1][0], dp[i-1][1] + prices[i])
        dp[i][1] = Math.max(dp[i-1][1], dp[i-1][0] - prices[i])
    }
    return dp[l-1][0]
};
```

### 714. 买卖股票的最佳时机含手续费

https://leetcode.cn/problems/best-time-to-buy-and-sell-stock-with-transaction-fee/

```js
var maxProfit = function (prices, fee) {
    const l = prices.length
    const dp = new Array(l).fill(0).map(() => new Array(2).fill(0))

    dp[0][0] = 0
    dp[0][1] = -prices[0] - fee
    for (let i = 1; i < l; i++) {
        dp[i][0] = Math.max(dp[i - 1][0], dp[i - 1][1] + prices[i])
        dp[i][1] = Math.max(dp[i - 1][1], dp[i - 1][0] - prices[i] - fee)
    }

    return dp[l - 1][0]
};
```


### ------背包问题------
01背包、完全背包、多重背包、分组背包和混合背包

一个商品如果可以重复多次放入是完全背包，而只能放入一次是01背包

第一层遍历物品，第二层遍历背包容量

假设旅行者的背包最多装1800件圣遗物，现有双爆评分记为[C1，C2，C3....Cn]的n件圣遗物需要装进背包，求旅行者能留下的圣遗物最大价值

### 416. 分割等和子集(01背包)

https://leetcode.cn/problems/partition-equal-subset-sum/description/

698.划分为k个相等的子集
473.火柴拼正方形

```js
var canPartition = function (nums) {
    const l = nums.length
    if(nums.length < 2) return false
    const sum = nums.reduce((pre, cur) => pre + cur, 0)
    if (sum % 2 !== 0) return false
    const capacity = sum / 2
    // dp[i][j] 代表前i个元素能否组成和为j的结果
    // [1, 5, 11, 5]
    const dp = new Array(l).fill(0).map(() => new Array(capacity).fill(false))

    // 第0项 满足 容量为nums[0]的背包
    dp[0][nums[0]] = true

    // 一步步扩大可选放入背包的物品范围，每片i轮询可理解为，i-1项中加入此i项能否满足容量j
    for (let i = 1; i < l; i++) {
        // 该层for循环，相当于遍历出了，前i项，能组合出来哪些容量。
        for (let j = 0; j <= capacity; j++) {
            // 对每新增的第i项进行容量遍历，判断 第i项 能不能放入 容量j 的背包，
            // 1. 如果 nums[i]  > 容量j 太大不能放入背包，那容量dp[i][j] 沿用之前 dp[i-1][j]的结果(可能i-1项可以满足 容量j，也算)
            // 2. 如果 nums[i] <= 容量j 那就有两种情况，
            // 情况1 第i项 放入， 那剩余的空间 j - nums[i]，看看dp[i-1]中是否能恰好填充，即dp[i-1][j - nums[i]]是否为true
            // 情况2 第i项 不放入， 那沿用 dp[i-1][j] 的结果(前i-1项能满足和为容量j也行)
            // 二者有一个成功即为true
            // 在遍历的过程中，已经考虑了背包容量 为 0 到 j 的所有情况
            if (nums[i] > j) {
                dp[i][j] = dp[i - 1][j]
            } else if (nums[i] < j) {
                // 也可理解为，i-1项能满足容量j也行，i-1项不能满足容量j的话就把 第i项 放入背包，看看i-1项，能不能满足剩余空间。
                dp[i][j] = dp[i - 1][j] || dp[i - 1][j - nums[i]]
            } else {
                dp[i][j] = true
            }
        }
        console.log(i,nums[i],dp[i])
    }
    // dp[l-1][capacity] 代表 用上nums所有元素(l-1),能否组合出容量capacity
    return dp[l - 1][capacity]
};

canPartition([1,5,11,5])
```

```js
// 滚动数组,由于每次的数据只依赖于上一层i-1的数据，所以可以直接在当前一维数组比
var canPartition = function(nums) {
    const sum = (nums.reduce((p, v) => p + v));
    if (sum & 1) return false;
    const dp = Array(sum / 2 + 1).fill(0);
    for(let i = 0; i < nums.length; i++) {
        // 容量j >= nums[i]代表当前i在这个容量都是有选择的，可放进去的
        for(let j = sum / 2; j >= nums[i]; j--) {
            // 假设 [1,5,11,5]
            // 第一轮就是 1 能放进容量 11，并与0比谁大。一轮下来就是[0,1,1,1,...]
            // 第二轮就是 5 能放进容量 11 到 0 的话， value加上 并且剩余质量能否补上，并与1比大
            dp[j] = Math.max(dp[j], dp[j - nums[i]] + nums[i]);
            if (dp[j] === sum / 2) {
                return true;
            }
        }
    }
    return dp[sum / 2] === sum / 2;
};

canPartition([1,5,11,5])
0 1  [ 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1 ]
1 5  [ 0, 1, 1, 1, 1, 5, 6, 6, 6, 6, 6, 6 ]
2 11 [ 0, 1, 1, 1, 1, 5, 6, 6, 6, 6, 6, 11 ]
3 5  [ 0, 1, 1, 1, 1, 5, 6, 6, 6, 6, 10, 11 ]
```

### 1049. 最后一块石头的重量 II(01背包)

https://leetcode.cn/problems/last-stone-weight-ii/description/

```js
// 前面的选择影响后面的选择，动态规划
var lastStoneWeightII = function (stones) {
    // 这题本质是找到尽可能接近 sum/2 的组，也即 背包的 value/容量 最大 为 sum/2。
    // dp[j]: 前j项最大价值为dp[j]
    // 总容量j 减去当前j的容量，剩余的容量的价值， 加上当前j的价值；与上一次ap[j]比出最大值
    // dp[j] = max(dp[j], dp[j - weight[i]] + value[i]);
    const l = stones.length
    if (l < 2) return stones[0]
    const sum = stones.reduce((p, c) => p + c)
    const maxCapacity = Math.ceil(sum / 2)
    const dp = new Array(maxCapacity + 1).fill(0)
    for (let i = 0; i < l; i++) {
        // 在前几次的遍历中，后面的j基本无意义，因为肯定会被覆盖，后续遍历中i物品变多，更能撑满背包
        for (let j = maxCapacity; j >= stones[i]; j--) {
            dp[j] = Math.max(dp[j], dp[j - stones[i]] + stones[i])
        }
        // console.log(i,stones[i],dp)
    }
    return Math.abs(dp[maxCapacity] * 2 - sum)
};

lastStoneWeightII([2,7,4,1,8,1])
```

### 494. 目标和(01背包,组合)

https://leetcode.cn/problems/target-sum/

```js
const findTargetSumWays = (nums, target) => {
    // 本质是 将数组分成两个集合，其中一个集合比另一个集合多result
    // 那就是 多的那个集合x = (sum + result) / 2,要想办法把这个集合放满有多少种方法
    
    const sum = nums.reduce((p, c) => p + c);
    if (Math.abs(target) > sum) return 0
    if ((target + sum) % 2) return 0
    // 正数集合，和必须为maxCapacity
    const maxCapacity = (target + sum) / 2;
    // console.log('sum', sum)
    // console.log('maxCapacity', maxCapacity)

    let dp = new Array(maxCapacity + 1).fill(0);
    dp[0] = 1;

    for (let i = 0; i < nums.length; i++) {
        // 相当于从前往后遍历i，前几轮遍历相当于看i能满足哪个容量
        // 后面的遍历，可以满足的容量更多，直至i = 4，
        for (let j = maxCapacity; j >= nums[i]; j--) {
            // 每新一轮j的遍历，都在上一轮能达到容量j的基础上 dp[j]，
            // + 假设j项已入集合，将剩余空间(j - nums[i]) 补满有多少种次数 dp[j - nums[i]]
            dp[j] = dp[j] + dp[j - nums[i]];
        }
        // console.log(i, nums[i], dp)
    }

    return dp[maxCapacity];
};

findTargetSumWays([2, 1, 2, 3, 5], 3)

// sum 13
// maxCapacity 8 正数集合和必须为8
// 0 2 [ 1, 0, 1, 0, 0, 0, 0, 0, 0 ]
// 1 1 [ 1, 1, 1, 1, 0, 0, 0, 0, 0 ]
// 2 2 [ 1, 1, 2, 2, 1, 1, 0, 0, 0 ]
// 3 3 [ 1, 1, 2, 3, 2, 3, 2, 1, 1 ]
// 4 5 [ 1, 1, 2, 3, 2, 4, 3, 3, 4 ]
```


### 474. 一和零

https://leetcode.cn/problems/ones-and-zeroes/description/

```js
// 物品的重量有了两个维度的01背包问题
var findMaxForm = function (strs, m, n) {

    // dp[i][j]：最多有i个0和j个1的strs的最大子集的大小为dp[i][j]。
    const dp = new Array(m + 1).fill(0).map(() => new Array(n + 1).fill(0))
    // dp[i][j] = Math.max(dp[i][j], dp[i- zeroNum][j- oneNum]+1)

    let zero = one = 0
    // 老规矩循环物品
    // 物品一个维度，物品的重量两个维度，需要三重循环
    for (let str of strs) {
        for(let c of str) {
            if(c==='0')zero++
            else one++
        }

        // 内层其实是滚动数组，滚动数组为了保证每个物品只被添加一次，需要倒叙遍历，这里两个都要倒序遍历
        for (let i = m; i >= zero; i--) {
            for (let j = n; j >= one; j--) {
                // ij不放进去 就继承dp[i][j]， ij放进去就计算剩余的位置放满要多少dp[i - zero][j - one]
                dp[i][j] = Math.max(dp[i][j], dp[i - zero][j - one] + 1)
            }
        }
    }

    return dp[m][n]
};
```

### 为什么滚动数组需要倒叙遍历？

因为滚动数组复用需要i-1轮遍历的结果，

假设从后往前做遍历，我们在做第i轮循环的时候，先计算 容量j 较大的数据，此数据会依赖 i-1 轮的遍历结果

    前面还依旧保留者 i-1次遍历的dp数据，以供第i轮使用。

假设从前往后做遍历，可以预见 容量j 较小的dp数据会先被覆盖成为 第i轮的数据，使得 容量j较大的数据无法复用 i-1轮的结果，

    或者说这样遍历，导致每轮i种，每个容量j 都基于了新的当前i去计算(视为有无数个i物品，也即完全背包问题) 

    以01背包的思路 甚至可以认为，这样从前往后遍历，已经不仅仅有i层，而是 i*j 层。因为每个 j-1 其实都已经被覆盖为了第j层的数据

### -------- 完全背包 --------
完全背包和01背包问题唯一不同的地方就是，每种物品有无限件。

01背包和完全背包唯一不同就是体现在遍历顺序上

01背包滚动数组是从大到小遍历，为了保证每个物品仅被添加一次。

而完全背包的物品是可以添加多次的，所以要从小到大去遍历


### 518. 零钱兑换 II

https://leetcode.cn/problems/coin-change-ii/description/

```js
var change = function (amount, coins) {

    // dp[i] 前i项能组成的总金额组合数
    const dp = new Array(amount + 1).fill(0)
    dp[0] = 1
    // 上一轮dp[i]有多少种方法 + 这轮剩余空间有多少种方法
    // dp[i] = dp[i] + dp[j-coins[i]]
    for (let i = 0; i < coins.length; i++) {
        for (let j = coins[i]; j <= amount; j++) {
            dp[j] = dp[j] + dp[j - coins[i]]
        }
    }

    return dp[amount]
};
```


这种遍历顺序中dp[j]里计算的是组合数
```js
for (int i = 0; i < coins.size(); i++) { // 遍历物品
    for (int j = coins[i]; j <= amount; j++) { // 遍历背包容量
        dp[j] += dp[j - coins[i]];
    }
}

// [1,2,5] 5
0 1 [ 1, 1, 1, 1, 1, 1 ]
1 2 [ 1, 1, 2, 2, 3, 3 ]
2 5 [ 1, 1, 2, 2, 3, 4 ]
```

这种遍历顺序中dp[j]里算出来的就是排列数！
```js
var change = function (amount, coins) {

    const dp = new Array(amount + 1).fill(0)
    dp[0] = 1
    for (let j = 0; j <= amount; j++) { // 1.遍历背包容量
        // 针对每一个容量j，遍历i
        for (let i = 0; i < coins.length; i++) { // 2.遍历物品
            if (j - coins[i] >= 0) dp[j] += dp[j - coins[i]];
        }
        console.log(j,dp)
    }
    return dp[amount]
};

// [1,2,5] 5
//  0  1  2  3  4  5
0 [ 1, 0, 0, 0, 0, 0 ]
1 [ 1, 1, 0, 0, 0, 0 ]
2 [ 1, 1, 2, 0, 0, 0 ]
3 [ 1, 1, 2, 3, 0, 0 ]
4 [ 1, 1, 2, 3, 5, 0 ]
5 [ 1, 1, 2, 3, 5, 9 ]
```


### 377. 组合总和 Ⅳ

https://leetcode.cn/problems/combination-sum-iv/description/
```js
var combinationSum4 = function(nums, target) {
    // dp[i] 前i项和为i的排列个数
    const dp = new Array(target + 1).fill(0)
    dp[0] = 1 // 0项组成0有一种方式
    // dp[i] = dp[i] + dp[i - nums[i]]
    for(let i = 0; i <= target; i++) {
        for(let j = 0; j < nums.length; j++) {
            if(i >= nums[j]) dp[i] = dp[i] + dp[i - nums[j]]
        }
    }
    return dp[target]
};

// [1,2,3] 4
0 [ 1, 0, 0, 0, 0 ]
1 [ 1, 1, 0, 0, 0 ]
2 [ 1, 1, 2, 0, 0 ]
3 [ 1, 1, 2, 4, 0 ]
4 [ 1, 1, 2, 4, 7 ]
```