---
title: 排序算法题
date: 2021-10-21 09:16:08
tags: 
    - 算法题
---

# 排序算法题

## 冒泡排序(bubbleSort)

```js
const bubbleSort = function(Array) {
    if(!Array.length || Array.length === 1) return Array
    for(let i = 0;i < Array.length;i++ ) {
        let flag = true
        for(let j = 0;j < Array.length-i-1;j++) {
            if(Array[j] > Array[j+1]) {
                flag = false // 如果存在某一轮没有轮换过，代表已经全部是递增了
                const temp = Array[j]
                Array[j] = Array[j+1]
                Array[j+1] = temp
            }
        }
        if(flag) break
    }
    return Array
}
let a = [2,35,4,4,6,8,4,1,5,6,31,56,-1]
console.log(bubbleSort(a));
```

## 选择排序(insertionSort)

注意，选择排序是 不稳定 的排序算法，交换的过程中打乱了原有的相对顺序
```js
// i把Array分为左边有序列，右边无序列
// 每轮从无序列中找出最小的 与 有序列最右侧i处 交换
// 与冒泡排序不同之处在于每轮交换次数只有一次
const selectionSort = function(Array) {
    if(!Array.length || Array.length === 1) return Array
    const len = Array.length
    for(let i = 0; i < len-1; i++) { // 注意这里不该是i<len,能省一点是一点
        let min = i
        for(let j = i+1; j < len; j++) { // 注意这里不该是j = i,能省一点是一点
            if(Array[min] > Array[j]) { min = j }
        }
        const temp = Array[i]
        Array[i] = Array[min]
        Array[min] = temp
    }
    return Array
}

let a = [2,35,4,4,6,8,4,1,5,6,31,56,-1]
console.log(selectionSort(a));
```

## 插入排序(insertionSort)

```js
// i把Array分为左边有序列，右边无序列
// 每轮把i依次从右往左对比，与比自己大的数交换 (XXX,错误思路)
// 保存i 每轮把i依次从右往左对比，比自己大的数，就右移，最后j+1放i
const insertionSort = (arr) => {
    if (arr.length <= 1) return
    // (0,i) 代表有序区间 i代表无序区间这轮即将要插入有序区间的数
    for (let i = 1; i < arr.length; i++) {
        const temp = arr[i]
        let j = i - 1
        // j 属于 [0,i-1],从后向前比较,比temp大的就后移
        for (j; j >= 0; j--) {
            if (arr[j] > temp) {
                arr[j + 1] = arr[j]
            } else {
                break
            }
        }
        // 直到 找到第一个<j或=j的数下标 或循环完j=-1,
        // temp放这个数后面(j+1)
        arr[j + 1] = temp
    }
    return arr
}
let a = [2,35,4,4,6,8,4,1,5,6,31,56,-1]
console.log(insertionSort(a));
```

## 合并两个有序数组( LeetCode 88 )
```js
var merge = function(nums1, m, nums2, n) {
    m--
    n--
    for(let i = nums1.length -1 ;n>=0; i --) { // 只要nums2全部排进1了就结束了
        nums1[i] = nums1[m] > nums2[n] ? nums1[m--] : nums2[n--]
    }
    return nums1
};
```

## 颜色分类( LeetCode 75 )

```js
// 只要原地排序就行，这里试一下插入排序
var sortColors = function(nums) {
    if(nums.length <= 1) return nums
    for(let i = 1; i < nums.length; i++) {
        const temp = nums[i]
        let j = i // 这里的插入排序不小心用了j = i,不是很符合逻辑，报了多次错才做出来
        for(j; j > 0; j--) { // 应该用 j = i - 1,其他地方对应修改
            if(nums[j-1] > temp) {
                nums[j] = nums[j-1]
            } else {
                break
            }
        }
        nums[j] = temp
    }
};
```

## 部分排序 （面试题 16）

[leetcode](https://leetcode-cn.com/problems/sub-sort-lcci/submissions/)

标准做法是：找两个数，
一个是 最靠左的 满足右边存在小于自己的数 的数， 最右边记为min，往左遇到 比min小的就替换min，遇到比min大的就是 左边界
一个是 最靠右的 满足左边存在小于自己的数 的数， 最左边记为max，往右遇到 比max大的就替换max，遇到比max小的 就是右边界

### 我的解法
```js
// 我是从左往右一个个判断这个数是不是当前最小的数，找到左边界，右边界同理。
var subSort = function(array) {
    let start = -1,end = -1;

    for(let i = 0; i < array.length; i++) {
        let flag = false
        for(let j = i + 1; j < array.length; j++) {
            if(array[i] > array[j]) {
                start = i
                flag = true
                break
            }
        }
        if(flag) break
    }

    for(let i = array.length - 1; i > start; i--) {
        let flag = false
        for(let j = i - 1; j > start; j--) {
            if(array[i] < array[j]) {
                end = i
                flag = true
                break
            }
        }
        if(flag) break
    }


    return [start,end]
};
```