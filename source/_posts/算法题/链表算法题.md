---
title: 链表算法题
date: 2021-10-13 15:25:36
categories: 技术栈
tags: 
    - 算法题
---

# 链表算法题

先考虑是否要创建一个新的变量专门接收数据

链表考什么？就是哨兵节点+虚拟节点+链表指针的移动

双指针

头部可能插值的问题都需要一个头空结点

所有的反转链表都要记住三步:

1.记录next节点,

2.修改cur.next指向,

3.反转next节点指向cur.

## 反转链表(LeetCode 206)
```js
var reverseList = function(head) {
    let root = new ListNode() // root 可以直接改为 = null
    let currentNode = head
    while (currentNode !== null) {
        const next = currentNode.next
        currentNode.next = root.next
        root.next = currentNode
        currentNode = next
    }
    return root.next
};
// 递归
var reverseList = function(head) {
    if (head === null || head.next === null) { return head; }
    const newHead = reverseList(head.next); // 从最后一个结点开始轮，此处返回最后一个结点
    head.next.next = head; // 倒数第二个 的下一个结点 的next 指向当前结点
    head.next = null; // 当前结点 也就是 倒数第二个结点 next为null
    // 注意，newHead永远都是最后一个节点
    // 每一层递归都记录了当前结点，以及当前节点的next节点，所以在上一层中直接把next置为null也不会丢失下一层的next
    // 外层会继续将next 置为前一个数
    return newHead;
}
```

## 相交链表(LeetCode 160)

```js
// 反转链表
var getIntersectionNode = function(headA, headB) {
    if (headA === null || headB === null) {
        return null;
    }
    let pA = headA, pB = headB;
    while (pA !== pB) {
        pA = pA === null ? headB : pA.next;
        pB = pB === null ? headA : pB.next;
    }
    return pA;
};
// 注意假设A和B等长，不会无限循环，因为 AB同为null时已经跳出循环了
```

## 合并两个有序链表 (LeetCode 21)

```js
// 迭代
var mergeTwoLists = function(l1, l2) {
    const preHead = new ListNode(-1);

    let prev = preHead;
    while (l1 && l2) {
        if (l1.val <= l2.val) {
            prev.next = l1;
            l1 = l1.next;
        } else {
            prev.next = l2;
            l2 = l2.next;
        }
        prev = prev.next;
    }
    prev.next = l1 === null ? l2 : l1;

    return preHead.next;
};
```

```js
// 递归
var mergeTwoLists = function(l1, l2) {
    if (l1 === null) {
        return l2;
    } else if (l2 === null) {
        return l1;
    } else if (l1.val < l2.val) {
        l1.next = mergeTwoLists(l1.next, l2);
        return l1;
    } else {
        l2.next = mergeTwoLists(l1, l2.next);
        return l2;
    }
};
```

__自己的解法__

```js
var mergeTwoLists = function(l1, l2) {

    let h1 = l1
    let h2 = l2
    let r = new ListNode()
    let rHEAD = r

    while(h1 && h2) {
        if(h1.val <= h2.val) {
            r.next = h1
            h1 = h1.next
        } else {
            r.next = h2
            h2 = h2.next
        }
        r = r.next
    }
    r.next = h1 ? h1 : h2

    return rHEAD.next
};
```

## 分隔链表 (LeetCode 86)

```js
var partition = function(head, x) {
    let small = new ListNode(0);
    const smallHead = small;
    let large = new ListNode(0);
    const largeHead = large;
    while (head !== null) {
        if (head.val < x) {
            small.next = head;
            small = small.next;
        } else {
            large.next = head;
            large = large.next;
        }
        head = head.next;
    }
    large.next = null;
    small.next = largeHead.next;
    return smallHead.next;
};
```
__自己的解法__
```js
// 用的是插入排序的思路，在链表里无法体现
// 但是如果是数组，则相当于原地排序，空间占用更优
var partition = function(head, x) {
    let p1 = new ListNode() // p1称为 小末尾指针，左侧是 小数组，右侧是 大数组
    let p2 = null // 巡游指针
    p1.next = head
    // 需要有个指针记录头部，因为原始的head前可能被插值，如:[2,1] 2
    let result = p1
    
    // 找到最后一个连续的小于x的节点 
    while(p1.next && p1.next.val < x) {
        p1 = p1.next
    }
    p2 = p1.next
    if(!p2) return head
    while(p2.next) {
        // 循环判断下一个节点 是否需要插入到 小数组内
        if(p2.next.val < x) {
            // 记录 小节点，并删除
            const temp1 = p2.next
            p2.next = temp1.next
            // 插入 小节点 到 小数组末尾
            temp1.next = p1.next
            p1.next = temp1
            // 小末尾指针 后移
            p1 = p1.next
        } else { // 如果大于等于，就指针后移，小于则不需要，因为下一个节点已经被删了，相当于后移了
            p2 = p2.next
        }
        
    }
    return result.next
};
```

## 环形链表 II (LeetCode 142)

```js
// 我想的是在节点上做标记，显然用set更好，记住这思路
var detectCycle = function(head) {
    const visited = new Set();
    while (head !== null) {
        if (visited.has(head)) {
            return head;
        }
        visited.add(head);
        head = head.next;
    }
    return null;
};
```

<!-- O(1)空间版 -->
```js
// 要理解 快慢指针 找链的环结构入口,要理解两个重要结论,
// 1.慢指针 走过的的长度 等于 环的长度
// 2.慢指针 从头走到环入口的长度 等于 慢指针 从相遇点走完剩余环的长度

// 假设 快指针 一次走 2个节点,慢指针 一次走 1个节点
// 假设 头到环入口长度 a, 环长度 b.
// 第 1 次相遇时, 快指针总路程 f,慢指针总路程 s,此时可得到两个等式
// (注意是第1次相遇,如果继续跑,第1次相遇后,s每跑1圈,f会跑2圈,会再次在这相遇,算法只需要考虑第1次相遇就行)
// f(快指针路程) = 2s(慢指针走的路程) (快指针是慢指针两倍速)
// f(快指针路程) = s(慢指针走的路程) + b(环的长度)
// 得到 s = b (慢指针走的路程 就是 环的长度b)
// 可理解为,第一次相遇的时候,s还刚进 第1圈,f已经多走了1圈环,所以 s=b
// 所以得到 重要结论 (1) 慢指针路程 s = b 环的节点数

// 接下来要思考,直觉上来说,为什么再次从头开始走一个 慢指针2
// 同时从第一次相遇处 走 慢指针1,两个慢指针必然会在 环入口处相遇?
// 换句话说 为什么 慢指针1 走完 剩余环的长度(y),会等于 从头到入环 的长度?

// 此时,我们整理下, 头到环入口a, 环入口到相遇处(x), 环长度b
// 很显然 环的长度(b) = x(入口到相遇处) + y(相遇处到环入口)
// 同时由结论(1) 环的长度(b) = s(慢指针路径) = a(头到环入口) + x(入口到相遇处)
// x(入口到相遇处) + y(相遇处到环入口) = a(头到环入口) + x(入口到相遇处)

// 语言解释就是, 头到相遇处, 相遇处再到环入口,是等长的,重合部分就是 入口到相遇处
// 路径上来说,都减去重合部分(入口到相遇处x),剩余部分路径相等
// 如果 假设两个慢指针,都不走重合部分,一个从头开始走,一个跳过重合部分从相遇处开始走
// 相同速度,走过相同路径时,便会相遇在入口

var detectCycle = function(head) {
    if (head === null) {
        return null;
    }
    let slow = head, fast = head;
    while (fast !== null) {
        slow = slow.next;
        if (fast.next !== null) {
            fast = fast.next.next;
        } else {
            return null;
        }
        if (fast === slow) {
            let ptr = head;
            while (ptr !== slow) {
                ptr = ptr.next;
                slow = slow.next;
            }
            return ptr;
        }
    }
    return null;
};
```

## 反转链表 II (LeetCode 92)

```js
// 要点，拆分子列，标记 左前与右 结点，左与右后 结点
var reverseBetween = function(head, left, right) {
    const pointH = new ListNode(-1,head) // 这类头部可能插值的问题都需要一个头空结点

    let pointL = pointH // 指向子链表left前一个结点
    for (let i = 0; i < left - 1; i++) {// 右移到left位置-1
        pointL = pointL.next
    }

    let pointR = pointL // 指向子链表right结点
    for (let i = 0; i < right - left + 1; i++) { // 右移差值+1个位置
        pointR = pointR.next
    }

    // 切出子链表，记录子链表头部 left，尾部 right的后一个结点
    let plr = pointL.next // 子链表的头部 left结点
    let prr = pointR.next // 子链表尾部 right的后一个结点

    // 切断
    pointL.next = null
    pointR.next = null

    pointL.next = reverseLinkedList(plr) // 左前结点拼上反转后的子链
    plr.next = prr // plr结点反转后已经是子链的right尾结点

    return pointH.next
};
var reverseLinkedList = function(head) {
    let root = null
    while(head) {
        const nextNode = head.next
        head.next = root
        root = head
        head = nextNode
    }
    return root
}
```

更优的解法,头插法

```js
var reverseBetween = function(head, left, right) {
    // 设置 dummyNode 是这一类问题的一般做法
    const dummy_node = new ListNode(-1);
    dummy_node.next = head;
    let pre = dummy_node;
    for (let i = 0; i < left - 1; ++i) {
        pre = pre.next;
    }

    let cur = pre.next;
    for (let i = 0; i < right - left; ++i) {
        const next = cur.next;
        cur.next = next.next;
        next.next = pre.next;
        pre.next = next;
    }
    return dummy_node.next;
};
```

## 复制带随机指针的链表(LeetCode 138)

```js
var copyRandomList = function (head) {
        if(head == null) { return null }
        let map = new Map() // map记录结点
        let cur = head;
        while(cur){
            map.set(cur,new Node(cur.val)) // 先创建一个个新节点，并储存
            cur = cur.next;
        }
        cur = head;
        while(cur){
            const curNode = map.get(cur)
            curNode.next = cur.next? map.get(cur.next):null // 根据旧节点，从hashMap拿到新节点
            curNode.random = map.get(cur.random)
            cur = cur.next;
        }
        return map.get(head);
    }
```

## 移除链表元素(LeetCode 203)

简单题

[leetcode](https://leetcode-cn.com/problems/remove-linked-list-elements/submissions/)

```js
var removeElements = function(head, val) {
    if(head === null) return null
    let tmpHead = new ListNode(-1) // 可能删除头节点的都得先设置伪头部
    tmpHead.next = head

    let cur = tmpHead
    while(cur.next) {
        if(cur.next.val === val) { // 删除了下一个就不用跳
            cur.next = cur.next.next || null
        } else {
            cur = cur.next
        }
    }

    return tmpHead.next
};
```

## 旋转链表(LeetCode 61)

[leetcode](https://leetcode-cn.com/problems/rotate-list/)

```js
var rotateRight = function(head, k) {
    if(!head) return head
    let H = new ListNode(-1,head)
    let end = start =  H
    let count = 0

    // 找到末尾节点,同时计算链表长度
    while(end.next) {
        count ++
        end = end.next
    }
    // 从头走到start节点,需要多少步
    let step = count - (k % count)
    // k = 链表长度count时不用变
    if(step === count) {return head}
    // 找到头节点
    while(step--) {
        start = start.next
    }
    // 开始把尾部切到头部
    end.next = H.next
    H.next = start.next
    start.next = null

    return H.next
};
```

leetcode提供的解法是头尾相接。

## 两两交换链表中的节点(LeetCode 24)

[leetcode](https://leetcode-cn.com/problems/swap-nodes-in-pairs/)

__递归__

只考虑头两个节点,首先知道,应当返回`head.next`作为`newHead`,

然后开始反转第一二节点,

先记录`head.next`节点为`newHead`(否则下一步会丢失`newHead`节点),

再马上修改`head.next`指向(相当于头反转为尾部),其指向为后续节点的`new newHead`,

即`swapPairs(newHead.next)`第三个节点为首的反转,

最后修改`newHead.next`指向`head`,完成一二节点的反转.结束.

注意:此处第一层(第一二节点)返回的是真正newHead,后续层返回的都是两两一对中的的next
```js
var swapPairs = function(head) {
    if(!head || !head.next) return head
    let newHead = head.next // 先把当前节点的next节点记录下来
    head.next = swapPairs(newHead.next) // 再修改当前节点的next指向
    newHead.next = head // 最后修改next节点指向当前节点
    return newHead
};
```
回头有空看看这个[递归解题三部曲](https://lyl0724.github.io/2020/01/25/1/)

__迭代__

```js
var swapPairs = function(head) {
    let p = H = new ListNode(-1,head);
    while (p.next !== null && p.next.next !== null) {
        const node1 = p.next; // 当前对的前节点(1节点)
        const node2 = p.next.next; // 当前对的后节点(2节点)
        node1.next = node2.next; // (1节点).next指向(2节点)下节点,同时丢失(2节点)(这就是为什么记录node2)
        node2.next = node1; // (2节点).next指向(1节点),反转链表
        p.next = node2; // 这一行没看懂,下面都直接改变p了,这里改的还有用吗,这一句又是干什么的
        p = node1;
    }
    return H.next;
};
```

__我的错误解答__

我把题目写成了 反转链表，每隔一个不反转......

且正好是答案的反转链表,写成反转的原因(仅仅指链表为什么被反转了)是,

返回的不是最初的head,而是将最后的节点作为结果层层传递了出去

我的错误解答 从后向前传递最后一层的newHead,而 正确答案 从后向前传递当前层newHead
```js
var swapPairs = function(head) {
    if(!head || !head.next || !head.next.next) return head
    let newHead = swapPairs(head.next.next)
    const last = head.next.next.next ? head.next.next.next : head.next.next
    last.next = head
    head.next.next = null
    return newHead
};
// 输入:[1,2,3,4,5]
// 输出:[5,3,4,1,2]
// leetcode题目的正确输出:[2,1,4,3,5]
```

## 删除链表的倒数第 N 个结点(LeetCode 19)

[leetcode](https://leetcode-cn.com/problems/remove-nth-node-from-end-of-list/)

```js
var removeNthFromEnd = function(head, n) {
    let r = l = H = new ListNode(-1,head)
    while(r) {
        r = r.next
        if(n-- < 0) l = l.next
    }
    l.next = l.next.next
    return H.next
};
```

这里本该先减(--n)，但这样结束后l就指向要删除的元素

我们这样l得指向要删除的元素之前的元素,所以改为后减n,l要少跑一轮

__我的解法__

我觉得快慢指针更好,这题是想练练递归
```js
var removeNthFromEnd = function(head, n) {
    const H = new ListNode(-1,head) // 可能头节点被删的都要有这句
    deleteN(H,n)
    return H.next
};
// 利用递归从后往前传n
var deleteN = function(current, n) {
    if(!current) return n
    const nowN = deleteN(current.next,n)
    if(nowN === 0) {
        current.next = current.next.next
    }
    return nowN - 1
}
```

## 链表的中间节点(LeetCode 876)

[leetcode](https://leetcode-cn.com/problems/middle-of-the-linked-list/)

```js
var middleNode = function(head) {
    let s = f = new ListNode(-1,head)
    while(f && f.next) {
        s = s.next
        f = f.next.next
    }
    return f ? s.next : s // f当前节点存在代表是偶数个
};
```

## 判断链表中存在环结构(LeetCode 141)

[leetcode](https://leetcode-cn.com/problems/linked-list-cycle/)
__快慢指针__
```js
var hasCycle = function(head) {
    let f = s = head
    while(s && s.next) {
        f = f.next
        s = s.next.next
        if(s === f) return true
    }
    return false
};
```
__HashSet__
(回头写下，也不复杂)
