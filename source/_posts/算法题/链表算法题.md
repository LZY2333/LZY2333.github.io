---
title: 链表算法题
date: 2021-10-13 15:25:36
categories: 技术栈
tags: 
    - 算法题
---

# 链表算法题


链表题常见解法

1. 创建一个新链表。`let newHead = new ListNode()`

2. 记录 __被循环的节点__ 的next。`const next = currentNode.next`


链表考什么？就是哨兵节点+虚拟节点+链表指针的移动



双指针

头部可能插值的问题都需要一个头空结点

p1之后插入节点p,`p.next = p1.next; p1.next = p`

要删除一个节点，需要知道这个节点的前一个节点，判断条件得是`p.next`。

## 2、反转链表（ LeetCode 206 ）

一个一个插入到newRoot节点后面，先记录下一个节点，再 currentNode.next = root.next
```js
var reverseList = function(head) {
    let root = new ListNode() // root 可以直接改为 = null
    let currentNode = head
    while (currentNode !== null) {
        const next = currentNode.next
        currentNode.next = root.next
        root.next = currentNode
        currentNode = next
    }
    return root.next
};
// 极简
var reverseList = function(head) {
    let [prev, current] = [null, head]
    while(current) {
        [current.next, prev, current] = [prev, current, current.next]
    }
    return prev
}
// 递归
// 假设列表的其余部分已经被反转，现在我们应该如何反转当前节点？
// 1.如果为null则当前就是头节点，返回
// 2.先反转后续的节点
// 3.再反转当前节点
var reverseList = function(head) {
    if (head === null || head.next === null) { return head; }
    const newHead = reverseList(head.next); // 从最后一个结点开始轮，此处返回最后一个结点
    head.next.next = head; // 倒数第二个 的下一个结点 的next 指向当前结点
    head.next = null; // 当前结点 也就是 倒数第二个结点 next为null
    // 每一层 递归都记录了当前结点，所以直接把next置为null也没关系
    // 外层会继续将next 置为前一个数
    return newHead;
}
```

## 3、相交链表（ LeetCode 160 ）(未解出)

循环条件是`pA !== pB`

```js
// 相交链表
var getIntersectionNode = function(headA, headB) {
    if (headA === null || headB === null) {
        return null;
    }
    let pA = headA, pB = headB;
    while (pA !== pB) {
        pA = pA === null ? headB : pA.next;
        pB = pB === null ? headA : pB.next;
    }
    return pA;
};
// 两个指针走的路程必然等长，不会无限循环，在 AB同为null时已经跳出循环了
```

## 4、合并两个有序链表 （ LeetCode 21 ）

```js
// 迭代
var mergeTwoLists = function(l1, l2) {
    const preHead = new ListNode(-1);

    let prev = preHead;
    while (l1 && l2) {
        if (l1.val <= l2.val) {
            prev.next = l1;
            l1 = l1.next;
        } else {
            prev.next = l2;
            l2 = l2.next;
        }
        prev = prev.next;
    }
    prev.next = l1 === null ? l2 : l1;

    return preHead.next;
};
```

```js
// 递归
var mergeTwoLists = function(l1, l2) {
    if (l1 === null) {
        return l2;
    } else if (l2 === null) {
        return l1;
    } else if (l1.val < l2.val) {
        l1.next = mergeTwoLists(l1.next, l2);
        return l1;
    } else {
        l2.next = mergeTwoLists(l1, l2.next);
        return l2;
    }
};
```

## 5、分隔链表 （ LeetCode 86 ）

```js
var partition = function(head, x) {
    let small = new ListNode(0);
    const smallHead = small;
    let large = new ListNode(0);
    const largeHead = large;
    while (head !== null) {
        if (head.val < x) {
            small.next = head;
            small = small.next;
        } else {
            large.next = head;
            large = large.next;
        }
        head = head.next;
    }
    large.next = null;
    small.next = largeHead.next;
    return smallHead.next;
};

// 空间复杂度0
var partition = function(head, x) {
    let p = root = new ListNode(-1, head)
    while(p.next && p.next.val < x) {
        p = p.next
    }

    let p2 = p.next
    if(!p2) return root.next
    while(p2.next) {
        if(p2.next.val < x) {
            const temp = p2.next
            p2.next = p2.next.next
            temp.next = p.next
            p.next = temp
            p = p.next
        } else {
            p2 = p2.next
        }
    }
    return root.next
};
```


## 6、环形链表 II （ LeetCode 142 ）

```js
// 我想的是在节点上做标记，显然用set更好，记住这思路
var detectCycle = function(head) {
    const visited = new Set();
    while (head !== null) {
        if (visited.has(head)) {
            return head;
        }
        visited.add(head);
        head = head.next;
    }
    return null;
};
```

<!-- O(1)空间版 -->
```js
// 要理解 快慢指针 找链的环结构入口,要理解两个重要结论,
// 1.慢指针 走过的的长度 等于 环的长度
// 2.慢指针 从头走到环入口的长度 等于 慢指针 从相遇点走完剩余环的长度

// 假设 快指针 一次走 2个节点,慢指针 一次走 1个节点
// 假设 头到环入口长度 a, 环长度 b.
// 第 1 次相遇时, 快指针总路程 f,慢指针总路程 s,此时可得到两个等式
// (注意是第1次相遇,如果继续跑,第1次相遇后,s每跑1圈,f会跑2圈,会再次在这相遇,算法只需要考虑第1次相遇就行)
// f(快指针路程) = 2s(慢指针走的路程) (快指针是慢指针两倍速)
// f(快指针路程) = s(慢指针走的路程) + b(环的长度)
// 得到 s = b (慢指针走的路程 就是 环的长度b)
// 可理解为,第一次相遇的时候,s还刚进 第1圈,f已经多走了1圈环,所以 s=b
// 所以得到 重要结论 (1) 慢指针路程 s = b 环的节点数

// 接下来要思考,直觉上来说,为什么再次从头开始走一个 慢指针2
// 同时从第一次相遇处 走 慢指针1,两个慢指针必然会在 环入口处相遇?
// 换句话说 为什么 慢指针1 走完 剩余环的长度(y),会等于 从头到入环 的长度?

// 此时,我们整理下, 头到环入口a, 环入口到相遇处(x), 环长度b
// 很显然 环的长度(b) = x(入口到相遇处) + y(相遇处到环入口)
// 同时由结论(1) 环的长度(b) = s(慢指针路径) = a(头到环入口) + x(入口到相遇处)
// x(入口到相遇处) + y(相遇处到环入口) = a(头到环入口) + x(入口到相遇处)

// 语言解释就是, 头到相遇处, 相遇处再到环入口,是等长的,重合部分就是 入口到相遇处
// 路径上来说,都减去重合部分(入口到相遇处x),剩余部分路径相等
// 如果 假设两个慢指针,都不走重合部分,一个从头开始走,一个跳过重合部分从相遇处开始走
// 相同速度,走过相同路径时,便会相遇在入口

var detectCycle = function(head) {
    if (head === null) {
        return null;
    }
    let slow = head, fast = head;
    while (fast !== null) {
        slow = slow.next;
        if (fast.next !== null) {
            fast = fast.next.next;
        } else {
            return null;
        }
        if (fast === slow) {
            let ptr = head;
            while (ptr !== slow) {
                ptr = ptr.next;
                slow = slow.next;
            }
            return ptr;
        }
    }
    return null;
};
```

## 7、反转链表 II （ LeetCode 92 ）

```js
// 要点，拆分子列，标记 左前与右 结点，左与右后 结点
var reverseBetween = function(head, left, right) {
    const pointH = new ListNode(-1,head) // 这类头部可能插值的问题都需要一个头空结点

    let pointL = pointH // 指向子链表left前一个结点
    for (let i = 0; i < left - 1; i++) {// 右移到left位置-1
        pointL = pointL.next
    }

    let pointR = pointL // 指向子链表right结点
    for (let i = 0; i < right - left + 1; i++) { // 右移差值+1个位置
        pointR = pointR.next
    }

    // 切出子链表，记录子链表头部 left，尾部 right的后一个结点
    let plr = pointL.next // 子链表的头部 left结点
    let prr = pointR.next // 子链表尾部 right的后一个结点

    // 切断
    pointL.next = null
    pointR.next = null

    pointL.next = reverseLinkedList(plr) // 左前结点拼上反转后的子链
    plr.next = prr // plr结点反转后已经是子链的right尾结点

    return pointH.next
};
var reverseLinkedList = function(head) {
    let root = null
    while(head) {
        const nextNode = head.next
        head.next = root
        root = head
        head = nextNode
    }
    return root
}
```

更优的解法,头插法

```js
var reverseBetween = function(head, left, right) {
    // 设置 dummyNode 是这一类问题的一般做法
    const dummy_node = new ListNode(-1);
    dummy_node.next = head;
    let pre = dummy_node;
    for (let i = 0; i < left - 1; ++i) {
        pre = pre.next;
    }

    let cur = pre.next;
    for (let i = 0; i < right - left; ++i) {
        const next = cur.next;
        cur.next = next.next;
        next.next = pre.next;
        pre.next = next;
    }
    return dummy_node.next;
};
```

## 8、复制带随机指针的链表（ LeetCode 138 ）

```js
var copyRandomList = function (head) {
        if(head == null) { return null }
        let map = new Map() // map记录结点
        let cur = head;
        while(cur){
            map.set(cur,new Node(cur.val)) // 先创建一个个新节点，并储存
            cur = cur.next;
        }
        cur = head;
        while(cur){
            const curNode = map.get(cur)
            curNode.next = cur.next? map.get(cur.next):null // 根据旧节点，从hashMap拿到新节点
            curNode.random = map.get(cur.random)
            cur = cur.next;
        }
        return map.get(head);
    }
```



## 自己的解法

### 4. 合并两个有序链表
```js
var mergeTwoLists = function(l1, l2) {

    let h1 = l1
    let h2 = l2
    let r = new ListNode()
    let rHEAD = r

    while(h1 && h2) {
        if(h1.val <= h2.val) {
            r.next = h1
            h1 = h1.next
        } else {
            r.next = h2
            h2 = h2.next
        }
        r = r.next
    }
    r.next = h1 ? h1 : h2

    return rHEAD.next
};
```

### 5.分隔链表
```js
// 用的是插入排序的思路，在链表里无法体现
// 但是如果是数组，则相当于原地排序，空间占用更优
var partition = function(head, x) {
    let p1 = new ListNode() // p1称为 小末尾指针，左侧是 小数组，右侧是 大数组
    let p2 = null // 巡游指针
    p1.next = head
    // 需要有个指针记录头部，因为原始的head前可能被插值，如:[2,1] 2
    let result = p1
    
    // 找到最后一个连续的小于x的节点 
    while(p1.next && p1.next.val < x) {
        p1 = p1.next
    }
    p2 = p1.next
    if(!p2) return head
    while(p2.next) {
        // 循环判断下一个节点 是否需要插入到 小数组内
        if(p2.next.val < x) {
            // 记录 小节点，并删除
            const temp1 = p2.next
            p2.next = temp1.next
            // 插入 小节点 到 小数组末尾
            temp1.next = p1.next
            p1.next = temp1
            // 小末尾指针 后移
            p1 = p1.next
        } else { // 如果大于等于，就指针后移，小于则不需要，因为下一个节点已经被删了，相当于后移了
            p2 = p2.next
        }
        
    }
    return result.next
};
```

## 移除链表元素（ LeetCode 203 ）

简单题

[leetcode](https://leetcode-cn.com/problems/remove-linked-list-elements/submissions/)

```js
var removeElements = function(head, val) {
    if(head === null) return null
    let tmpHead = new ListNode(-1) // 可能删除头节点的都得先设置伪头部
    tmpHead.next = head

    let cur = tmpHead
    while(cur.next) {
        if(cur.next.val === val) { // 删除了下一个就不用跳
            cur.next = cur.next.next || null
        } else {
            cur = cur.next
        }
    }

    return tmpHead.next
};