---
title: 链表算法题
date: 2021-10-13 15:25:36
tags: 
    - 算法题
---

# 链表算法题

先考虑是否要创建一个新的变量专门接收数据

## 2、反转链表（ LeetCode 206 ）
```js
var reverseList = function(head) {
    let root = new ListNode()
    let currentNode = head
    while (currentNode !== null) {
        const next = currentNode.next
        currentNode.next = root.next
        root.next = currentNode
        currentNode = next
    }
    return root.next
};
// 递归
var reverseList = function(head) {
        if (head === null || head.next === null) { return head; }
        const newHead = reverseList(head.next);
        head.next.next = head;
        head.next = null;
        return newHead;
    }
```

## 3、相交链表（ LeetCode 160 ）(未解出)

```js
// 反转链表
var getIntersectionNode = function(headA, headB) {
    if (headA === null || headB === null) {
        return null;
    }
    let pA = headA, pB = headB;
    while (pA !== pB) {
        pA = pA === null ? headB : pA.next;
        pB = pB === null ? headA : pB.next;
    }
    return pA;
};
// 注意假设A和B等长，不会无限循环，因为 AB同为null时已经跳出循环了
```

## 4、合并两个有序链表 （ LeetCode 21 ）

```js
// 迭代
var mergeTwoLists = function(l1, l2) {
    const preHead = new ListNode(-1);

    let prev = preHead;
    while (l1 && l2) {
        if (l1.val <= l2.val) {
            prev.next = l1;
            l1 = l1.next;
        } else {
            prev.next = l2;
            l2 = l2.next;
        }
        prev = prev.next;
    }
    prev.next = l1 === null ? l2 : l1;

    return preHead.next;
};
```

```js
// 递归
var mergeTwoLists = function(l1, l2) {
    if (l1 === null) {
        return l2;
    } else if (l2 === null) {
        return l1;
    } else if (l1.val < l2.val) {
        l1.next = mergeTwoLists(l1.next, l2);
        return l1;
    } else {
        l2.next = mergeTwoLists(l1, l2.next);
        return l2;
    }
};
```

## 5、分隔链表 （ LeetCode 86 ）

## 6、环形链表 II （ LeetCode 142 ）

## 7、反转链表 II （ LeetCode 92 ）

## 8、复制带随机指针的链表（ LeetCode 138 ）


## 自己的解法

### 4. 合并两个有序链表
```js
var mergeTwoLists = function(l1, l2) {

    let h1 = l1
    let h2 = l2
    let r = new ListNode()
    let rHEAD = r

    while(h1 && h2) {
        if(h1.val <= h2.val) {
            r.next = h1
            h1 = h1.next
        } else {
            r.next = h2
            h2 = h2.next
        }
        r = r.next
    }
    r.next = h1 ? h1 : h2

    return rHEAD.next
};
```

### 5.分隔链表
```js
var partition = function(head, x) {
    let p1 = new ListNode() // p1称为 小末尾指针，左侧是 小数组，右侧是 大数组
    let p2 = null // 巡游指针
    p1.next = head
    // 需要有个指针记录头部，因为原始的head前可能被插值，如:[2,1]
    let result = p1
    
    // 找到最后一个连续的小于x的节点 
    while(p1.next && p1.next.val < x) {
        p1 = p1.next
    }
    p2 = p1.next
    if(!p2) return head
    while(p2.next) {
        // 循环判断下一个节点 是否需要插入到 小数组内
        if(p2.next.val < x) {
            // 记录 小节点，并删除
            const temp1 = p2.next
            p2.next = temp1.next
            // 插入 小节点 到 小数组末尾
            temp1.next = p1.next
            p1.next = temp1
            // 小末尾指针 后移
            p1 = p1.next
        } else { // 如果大于等于，就指针后移，小于则不需要，因为下一个节点已经被删了，相当于后移了
            p2 = p2.next
        }
        
    }
    return result.next
};
```
