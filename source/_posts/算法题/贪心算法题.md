---
title: 贪心算法题
date: 2021-10-27 15:21:49
tags: 
    - 算法题
---

# 贪心算法题

__学到的解题方法__


## 分发饼干(LeetCode 455)

[leetcode](https://leetcode-cn.com/problems/assign-cookies/)

假设你是一位很棒的家长，想要给你的孩子们一些小饼干。

但是，每个孩子最多只能给一块饼干。

对每个孩子 i，都有一个胃口值 g[i]，这是能让孩子们满足胃口的饼干的最小尺寸；

并且每块饼干 j，都有一个尺寸 s[j] 。

如果 s[j] >= g[i]，我们可以将这个饼干 j 分配给孩子 i ，这个孩子会得到满足。

你的目标是尽可能满足越多数量的孩子，并输出这个最大数值。

__96.95%__ 击败
__94.08%__ 击败
```js
var findContentChildren = function(g, s) {
    let gp = 0,sp = 0
    g.sort((l,r) => l - r)
    s.sort((l,r) => l - r)
    while(gp < g.length && sp < s.length) {
        if(g[gp] <= s[sp]) {
            gp ++
        }
        sp ++
    }
    return gp
};
```

## 柠檬水找零(leetcode 860)

"不带零钱你卖什么柃檬水？"

[leetcode](https://leetcode-cn.com/problems/lemonade-change/)

在柠檬水摊上，每一杯柠檬水的售价为 5 美元。

顾客排队购买你的产品，（按账单 bills 支付的顺序）一次购买一杯。

每位顾客只买一杯柠檬水，然后向你付 5 美元、10 美元或 20 美元。

你必须给每个顾客正确找零，也就是说净交易是每位顾客向你支付 5 美元。

注意，一开始你手头没有任何零钱。

给你一个整数数组 bills ，其中 bills[i] 是第 i 位顾客付的账。

如果你能给每位顾客正确找零，返回 true ，否则返回 false 。

__98.18%__ 击败
__86.49%__ 击败

```js
var lemonadeChange = function(bills) {
    let fc = 0,tc = 0,i = 0
    for(; i < bills.length; i++) {
        const count = bills[i] / 5 - 1
        if(count === 0) { // + 5*1
            fc++
        } else if(count === 1) { // + 10*1, - 5*1
            tc++
            fc--
            if(fc < 0) return false
        } else if(count === 3) { // + 20*1(不记录), - 10*1 - 5*1 或 - 5*3
            if(tc) {
                tc --
                fc --
            } else {
                fc = fc - 3
            }
            if(fc < 0) return false
        }
    }
    return true
};
```

## 用最少数量的箭引爆气球(leetcode 452)

其实就是区间覆盖,给几个区间,每个区间存在重复与不充分,找出最多的重复区间

[leetcode](https://leetcode-cn.com/problems/minimum-number-of-arrows-to-burst-balloons/)

答案没太看懂,靠右,射左的方式,我想改成靠左射右

```js
var findMinArrowShots = function(points) {
    if (!points.length ) {
        return 0;
    }

    points.sort((a, b) => a[1] - b[1]);
    let pos = points[0][1]
    let ans = 1;
    for (let balloon of points) {
        if (balloon[0] > pos) {
            pos = balloon[1];
            ans++;
        }
    }
    return ans;
};
```

### 我的解法
```js
var findMinArrowShots = function(points) {
    points = points.sort((l,r) => l[0] - r[0] || l[1] - r[1]) // 左端点相等要按右端点最小的来
    let count = 0,i = 0;
    while(i < points.length) {
        count ++
        // 每一个区间,找其下j个区间,
        // 当这下j个区间 左节点 <= 当前区间 右节点(等于也算重合)
        // 表示有重合区域,可一箭(1count)同时射穿,所以while循环跳过
        let j = 1,right = points[i][1] // right边界最初为当前区间right,后续为了穿过重复区间
        while(points[i+j] && points[i+j][0] <= right) { // right会不断缩小
            right = points[i+j][1] < right ? points[i+j][1] : right
            j ++
        }
        i += j
    }
    return count
};
```

## 移掉K位数字(leetcode 402)

[leetcode](https://www.algomooc.com/algocamp2)