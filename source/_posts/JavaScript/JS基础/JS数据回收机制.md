---
title: JS数据回收机制
date: 2021-07-01 00:04:15
tags: 
    - JS基础
---

### JS数据回收机制

回收机制分为 手动回收(C/C++) 自动回收(JS/Java/Python)

#### 栈中的数据回收

在 __执行上下文栈__ 中存在一个指针 指向当前执行函数的 执行上下文,

记录当前执行状态的指针 称为 __ESP__

当前 函数执行完毕时,__ESP__ 指针下移,即代表当前执行上下文被销毁,数据已被回收

> 因为数据虽然还在内存中,但已经是无效内存,后续有新数据会直接堵盖这块内存

#### 堆中的数据回收

1.__代际假说__(The Generational Hypothesis),认为对象分为两种,大部分为 短命的,少部分为 长寿的

2.V8引擎 将堆分为两个部分,__新生代__ 对应 __副垃圾回收器__,__老生代__ 对应 __主垃圾回收器__
> 新生代 就是短命的, 老生代 就是长寿的 或 内存占用大的

3.不管什么垃圾回收器 都基本分为三步,
    首先,标记 __活动对象__ 和 __非活动对象__(该删除的),
    然后,完成标记,统一回收 __非活动对象__ 的内存, 此时会产生 不连续的内存空间 __内存碎片__
    最后,整理内存碎片

4.__新生代__ 的 __副垃圾回收器__ 采用 __Scavenge 算法__
> Scavenge 算法 新生区空间 分为两个区域, 对象区域 和 空闲区域
> 一,对象区域 快被写满时, 副垃圾回收器 将 活动对象 复制到 空闲区域
> 二,完成复制,将 空闲区域 和 对象区域 角色翻转
> 由于 复制需要时间成本较高 ,所以 新生区内存空间较小

5.__对象晋升策略__,经过两次垃圾回收依旧存活的对象,会被移动到 __老生区__

6.__老生代__ 的 __主垃圾回收器__ 采用 __标记-清除(Mark-Sweep)算法__ 进行垃圾回收,
    采用 __标记-整理(Mark-Compat)算法__ 进行 __内存碎片__ 整理

7.__可访问性(reachablility)算法__,V8采用来判断堆中的对象是否为活动对象的算法
> 可访问性算法,将一些 GC Root 作为初始存活对象的集合,遍历其中所有对象
> 能被遍历到的对象 为活动对象,否则 为非活动对象
> GC Root 包括但不限于, wimdow对象(每个iframe),文档DOM树,栈中的变量
> 整理方法是 将所有 存活的对象向一端移动,清理掉边界以外的内存

7.__全停顿(Stop-The-World)__,JS运行在主线程上,执行垃圾回收算法,就得将JS脚本的执行暂停

8.__增量标记(Incremental Marking)算法__,将标记过程 划分为一个个小的子标记过程,
    让垃圾回收标记 与 JS脚本的执行 交替进行,直到标记阶段完成.