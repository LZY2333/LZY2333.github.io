---
title: 阅读杂记JS
date: 2022-05-10 05:51:23
categories: 经验帖
tags:
    - JS基础
    - 杂记
summary: jS杂记，阅读杂记系列为 【对日常看过的一些有趣帖子的笔记】/【对某一细节进行搜索深入了解后的分析】/【对某一技术原理架构分析后的脑图】，总贴记录 待研究的知识点 及 小知识点，分贴记录大知识点
---

# 阅读杂记JS

## 一共有哪些数据类型

8种: `null`，`undefined`，`boolean`，`number`，`string`，`Object`，`Symbol`，`BigInt`

### Symbol 表示独一无二的值

1. `Symbol` 接收一个参数表示对`Symbol`值的一种描述，`const s1 = Symbol('foo')`，

2. 传入相同的参数，生成的`Symbol`也不同

3. `const s2 = Symbol.for('foo')`方法会检测上文中是否已存在相同参数创建的`Symbol`，存在则返回该`Symbol`，不存在则新建

最常见是在开源库内作为常量，比如用来自定义一个类型 比如 react源码内的 `const REACT_ELEMENT = Symbol.for('react.element')`

或者是作为开源库内的 对象属性， `Object.keys` 和`Object.getOwnPropertyNames` 均不会返回`Symbol`，

`Object.getOwnPropertySymbols`可以返回对象所有`Symbol`属性

### BigInt 用来表示大于 2^53-1 的整数

`BigInt` 真没怎么用过，只知道是用来表示 大于 2^53-1 的数的，末尾加n就行

JS所有数字均以 __双精度64位浮点格式__ 表示.



## 如何判断数据类型

### typeof 能判断8种基本类型 function

`typeof` 能判断8种基本类型，及`function`类型，`Object`的衍生类型都只能返回`object`(全部小写)

### instanceof 能判断 实例 的 对象类型

`instanceof` 能判断实例的对象类型，不能判断8种基本数据类型，原理是顺着原型链找，也就是prototype

`console.log(people1 instanceof People); // true`

### Object.prototype.toString.call() 能判断所有内置类型

`Object.prototype.toString.call([]); // "[object Array]"`(类型首字母大写)

### 如何判断变量为数组

```js
Array.isArray(arr); // true
arr.__proto__ === Array.prototype; // true
arr instanceof Array; // true
Object.prototype.toString.call(arr); // "[object Array]"
```

## 原型和原型链(对象属性的查找)

__原型__: 每个JS对象创建的时候其`prototype`都会指向另一个对象，这个对象就是原型.

__原型链__: 每个实例都有自己的原型，原型也是对象，也具有自己的原型，这样的链式结构就是原型链.

查找对象的属性时，会沿着原型链依次向上查找该属性.

## 执行上下文(变量的查找)

### 什么是执行上下文栈，调用栈

__JS执行机制__: 以代码块为单位 先编译后执行，分为 __编译阶段__ 和 __执行阶段__.

("代码块"有三种:全局代码、函数代码、eval代码。)

__编译阶段__: 会生成两部分 __执行上下文__ 和 __可执行代码__

__执行上下文__: 包含了当前代码在执行期间要用到的 This、变量、对象以及函数等.
(__变量对象(Variable object)__:变量环境/词法环境 __作用域链(Outer)__ __This__)

__执行上下文栈__: 用来管理这些执行上下文，是一个 先进后出的 栈结构.

JS执行时首先会遇到全局代码，栈内压入全局上下文.
然后执行到一个函数时，会 从全局执行上下文中取出这段函数的代码进行编译
创建该函数的执行上下文，又压入栈内.函数执行完毕，又弹出该执行上下文.

__执行上下文栈__ 其实就是 JavaScript 引擎追踪函数执行的一个机制，和函数执行时的变量查找没什么关系
当一次有多个函数被调用时，通过调用栈就能够追踪到哪个函数正在被执行以及各函数之间的调用关系。

__栈溢出__ 函数递归没有终止条件，不停压入 执行上下文，导致栈溢出

### 什么是变量提升

JS的执行机制是 以代码块为单位，先编译后执行，分为编译阶段和执行阶段

编译阶段会生成两部分 执行上下文 和 可执行代码

在执行代码之前，其实已经将所有的变量 在 执行上下文 准备好了

使得代码看起来，可以在变量定义之前就访问到该变量

变量提升是JS的一个重要设计缺陷， 在ES6中 用 块级作用域 配合 const let 避免这种缺陷。

__作用域__: 函数和变量的可被访问的范围，生效范围 (全局作用域 函数作用域 块级作用域)

JS的设计者一开始也没想到JS会这么火，没有设计的那么复杂。
没想到简单恰恰导致了JS火起来，而火起来后又需要更多的规范
这就像开发一个项目一样，功能简单 意味着 领域专注 快速开发 成本降低

__缺陷__: 变量污染 变量覆盖

### const/let解决变量提升(执行上下文的变量环境 和 词法环境)

执行上下文中 分为 __变量环境__ 和 __词法环境__

__变量环境__ 储存`var`声明的变量

__词法环境__ 是一个栈，以块级作用域为 单位储存`const`/`let`声明的变量.类似 __执行上下文栈__ 的使用机制

编译阶段:
函数作用域内所有 var声明的变量 创建并初始化 在 __变量环境__，
函数作用域内`const`/`let` 创建不初始化 在 __词法环境__ 栈底，
> 这里其实是 块级作用域(这里相当于函数作用域内所有，且剔除内部其他块级作用域内的变量)

执行阶段:
执行到块级作用域，块级作用域中的 所有 `const`/`let` 变量立即 创建，并压入 __词法环境__ 栈底，
此时变量已被创建，但如果在声明之前调用 `const`/`let` 变量，由于未 初始化，JS引擎报错 __暂时性死区__
此时变量的查找顺序为，先从 __词法环境__ 栈顶找到栈底，再找 __变量环境__ 

`var`的创建和初始化被提升，赋值不会被提升。
`let`的创建被提升，初始化和赋值不会被提升。
`function`的创建、初始化和赋值均会被提升

### 作用域和作用域链(变量的查找)

和直觉不同，__变量的查找 并非 沿着执行上下文栈进行__
```js
function bar() {
    console.log(myName)
}
function foo() {
    var myName = "lzy内"
    bar()
}
var myName = "lzy外"
foo() // "lzy 外"
```

__作用域__: 函数和变量的可被访问的范围，生效范围 (全局作用域 函数作用域 块级作用域)

1.变量能够引用，函数能够生效的区域。
2.限制了你对内存空间上值的获取和修改。
3.JS引擎根据名称来查找变量的一套规则。
4.JS引擎通过查找作用域来解析标识符。

__作用域链__: 查找变量的路径，在 __执行上下文__ 的 __变量环境__ 中，包含一个外部引用 `outer` 值向外部的 __执行上下文__

__词法作用域__: __函数的作用域包括作用域链 在函数定义 函数编译的时候就确定了，与函数调用无关__

[刻刻帝丶大佬的文章](https://blog.csdn.net/q1056843325/article/details/53086893?locationNum=12&fps=1)
### 闭包

__闭包__: 函数定义时，可访问的外部函数变量集合(可以访问，但不一定访问了，因为当前内部函数没访问，其他内部函数访问了也会被保留并算在内)
__闭包__: 根据词法作用域规则，内部函数总是可以访问到外部函数(outer)中的变量，即使外部函数已经执行结束，内部函数引用的外部函数的变量依旧存在于内存，未被内部函数引用的外部变量会被销毁

__闭包产生的条件__: 必须存在内部函数使用了外部函数的变量，无需内部函数被外部持有

__多个内部函数共享共同一个闭包__，
当外部函数有多个内部函数，只要任意内部函数使用了外部函数的变量，所有内部函数均持有闭包，且共享同一个闭包.

返回内部函数时，JS引擎会提前分析闭包内部函数的词法环境，有引用的外部变量都不会被gc回收.

### This

__This机制__: 使用对象来调用其某个方法属性，该方法内部的This，指向的是对象

__This机制的意义__: 为了在对象内部的方法中使用对象内部的属性(然后用到原型链)

__原型链机制的意义__: 查找对象的属性时,会沿着原型链依次向上查找该属性.

__缺陷__: __嵌套函数的This不会从外部函数继承__(箭头函数解决)

> 普通函数的This默认指向全局对象window
> 各种开源库中 函数返回函数 经常会先bind(This)一下，就是因为这个缺陷
> 原型链 与 作用域链 机制类似，却不是一套

## 事件循环/宏任务和微任务

## Promise 和 async/await 有什么联系

## 手写Promise

## 手写call/apply/bind

## 手写new

## 手写深拷贝

__浅拷贝__，如果复制的对象是基本数据类型，拷贝的就是值，如果是引用类型，拷贝的就是内存地址，一个对象改变会影响另一个对象

### `JSON.parse(JSON.stringify())` 基本能用版

1. `JSON.parse(JSON.stringify())`，写法简单，但无法拷贝函数，循环引用，或特殊引用类型.

### forIn遍历，递归自身，丐版

```js
function clone(target) {
    if (typeof target !== 'object') return target;

    let cloneTarget = {};
    for (const key in target) {
        cloneTarget[key] = clone(target[key]);
    }
    return cloneTarget
};
```

### `cloneTarget=[]`兼容数组，`map`解决循环引用，够用了版

我没事的时候看架构组源码，看到一个大佬写的很好，就背下来了
```js
/**
 * 深拷贝
 * @param {Object} target 要拷贝的对象
 * @param {WeakMap} map 用于存储循环引用对象的地址
 */
function deepClone(target， map = new WeakMap()) {
    if (typeof target !== 'object') return target;

    if (map.get(target)) { // `map`解决循环引用
        return map.get(target);
    }

    let cloneTarget = Array.isArray(target) ? [] : {}; // 兼容数组
    
    map.set(target， cloneTarget);

    for (const key in target) {
        if (obj.hasOwnProperty(key)) { // forIn会循环原型链上的可枚举属性，这里去掉
            cloneTarget[key] = deepClone(target[key]， map);
        }
    }
    return cloneTarget
};
```

### WeakMap弱引用 与 `{}`强引用

### forIn循环效率低，while循环效率高，性能优化版

### 函数类型及特殊引用类型得专门判断
`Map`， `Set` 等类型得专门判断

## 0.1 + 0.2 !== 0.3，如何解决

## 写一个发布订阅模型
