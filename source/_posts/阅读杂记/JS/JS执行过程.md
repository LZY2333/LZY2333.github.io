---
title: JS执行过程
date: 2022-06-14 10:01:08
categories: 经验帖
tags:
    - JS基础
    - 杂记
summary: JS执行以代码段为单位,分为 三个阶段:语法分析 /创建阶段/ 执行阶段。作用域链是JS引擎查找变量的规则，原型链是JS引擎查找对象属性的规则
---

# JS执行过程

要了解JS的执行，首先要理解 __原型链__ __执行上下文__ __变量对象__  __作用域链__  __This__

__作用域链机制的意义__: JS查找 变量 的规则,会沿着作用域链[[scope]]向下查找

__原型链机制的意义__: JS查找 对象属性 的规则,会沿着原型链依次向上查找该属性.

__This机制的意义__: JS 为了在对象内部的方法中使用对象内部的属性（然后用到原型链） 的规则.

### 原型链

**prototype**:每个函数都具有的属性，且只有函数才有的属性。函数的prototype所指向的对象，就是该函数作为构造函数创建的*实例的原型对象*。

**__proto__**:每一个JavaScript对象（除nul）都具有的属性，这个属性会指向该*对象的原型*。

**constructor**:每一个原型都具有的属性，该属性指向关联这个*原型的构造函数*。

每一个JS对象在创建时都会与之关联一个对象，这个对象就是原型，每一个对象都会从原型"继承"属性。

[深入原型到原型链]（https://luoziyu.cn/2021/02/07/javascript/shen-ru-js-xi-lie/1.cong-yuan-xing-dao-yuan-xing-lian/）

### 执行上下文（ES3时代）

__JS执行机制__: 以代码块为单位 先编译后执行，分为 __创建阶段__ 和 __执行阶段__.

（"代码块"有三种:全局代码、函数代码、eval代码。）

__创建阶段__: 会生成两部分 __执行上下文__ 和 __可执行代码__

__执行上下文__: 是一段代码时的运行环境，包括执行期间要用到的 __变量对象__ / __作用域链__ / __This__

__执行上下文栈__: 用来管理这些执行上下文，是一个 先进后出的 栈结构.

__执行上下文栈__ 其实就是 JavaScript 引擎追踪函数执行的一个机制，和函数执行时的变量查找没什么关系

当一次有多个函数被调用时，通过调用栈就能够追踪到哪个函数正在被执行以及各函数之间的调用关系。

JS执行时首先会遇到全局代码，栈内压入 全局执行上下文.

然后执行到一个函数时，会 从 全局执行上下文 中取出这段函数的代码进行编译

创建该函数的执行上下文，又压入栈内.函数执行完毕，又弹出该执行上下文.

### 变量对象（ES3时代）

__变量对象__ / __作用域链__ / __This__,是执行上下文的三个重要属性

__变量对象__ 包含 当前上下文定义的 __形参（arguments）__ __函数声明__ __变量__ 的对象, 用于可执行代码执行时查找变变量，

在进入执行上下文时（创建阶段） 时创建

__全局对象（GO）__ 全局执行上下文 的 变量对象 就是 全局变量的宿主, 就是全局对象 其 window属性指向自己

__活动对象（AO）__ 函数执行上下文 的 变量对象.

变量对象 只是一个储存了所有变量的对象的概念

### 作用域链（ES3时代）

__作用域__

其实就是 变量对象, 代表 函数和变量的可被访问的范围，生效范围.

变量存在于哪个 作用域 或 属于哪个变量对象,就可以在这个变量对象内被访问.

__作用域链__

是JS查找变量的一套规则,本质上是由多个执行上下文的变量对象构成的链表,

链表的层级由 词法作用域 决定,查找变量时,会沿着作用域链查找.

__作用域链1__ （函数创建时产生）

外层代码段编译时, 作为一个对象, 会产生一个内部属性 [[scope]],

并根据 词法作用域,从内到外层层将父代码段的 变量对象 保存其中.

__词法作用域__

也是 __静态作用域__,JS的 作用域 由函数定义的位置决定,而不是执行时的 调用栈决定.

因为函数他所能引用的外部变量[[scope]],在函数创建的时候就已经决定了,而不是函数执行的时候

__作用域链2__（函数调用时产生）

（进入自己的创建阶段,创建自己的执行上下文,压入执行上下文栈）

复制自己 [[scope]]属性 创建作用域链2, 创建自己的AO并初始化, 压入作用域链顶端.

### This

This 的目的是使函数能访问其调用者的属性。

注意，普通函数中的 this 默认指向全局对象 window，在严格模式下，是 undefined

ES6箭头函数解决的问题：嵌套函数中的 this 不会从外层函数中继承

### JS执行（ES3时代）

JS是 __解释型语言__,边编译边执行.

JS执行 以 代码段 为单位,主要分为 三个阶段:__语法分析__ / __创建阶段__ / __执行阶段__

代码段 有三种: 全局代码 函数代码 eval代码

#### 第一步，语法分析

将代码分成 token,将 token解析成AST语法树（语法检查,报错）

分析该js脚本代码块的语法是否正确，

如果语法不正确，则抛出一个语法错误，停止该代码块的执行，然后继续查找并加载下一个代码块

如果语法正确，则进入创建阶段。

#### 第二步，创建阶段

##### 创建执行上下文，压入执行上下文栈

每进入一个 代码段, 或者说函数被调用时,便会创建相应的 __执行上下文__, 压入 __执行上下文栈__

##### 初始化执行上下文

主要初始化 执行上下文 的三个重要属性, __变量对象（Variable object）__ __作用域链（Outer）__ __This__

__作用域链（Scope Chain__

复制函数 [[scope]] 属性创建作用域链

> 注意是复制而不是修改,因为函数可能被多次调用,应当保证每次调用时,变量初始状态相同

__变量对象（Variable Object）__

依次检查 形参（Arguments对象） 函数声明 var声明变量（已有同名函数声明则跳过） 加入 VO

将 活动对象 压入 作用域链 顶端

此时的 VO 不能被直接访问，只有进入执行阶段，成为 活动对象（Active Object） 才能被访问。

__This__

#### 第三步，执行阶段

S 代码开始逐条执行，在这个阶段，JS 引擎开始对定义的变量赋值、开始顺着作用域链访问变量，

如果内部有函数调用就创建一个新的执行上下文压入执行栈并把控制权交出

#### 第四步，销毁阶段

当前执行上下文（局部环境）会被弹出执行上下文栈并且销毁，控制权被重新交给执行栈上一层的执行上下文

### 执行上下文（ES5时代）

__执行上下文__: 是一段代码时的运行环境，包括执行期间要用到的 __词法环境__ / __变量环境__ / __This__

作用域 --> 词法环境
VO|AO --> 环境记录 
作用域链 --> outer引用

```js
ExecutionContext = {
  ThisBinding = <this value>,
  LexicalEnvironment = { ... },
  VariableEnvironment = { ... },
}
```

### 词法环境 和 变量环境（ES5时代）

#### 词法环境（Lexical Environment）

一个 标识符（变量/函数的名称） 与 变量（实际对象/原始值的引用） 相映射的结构,包括

1.__环境记录__（environment record） 储存变量和函数生命的实际位置

2. __对外部环境的引用__ 意味着可以访问外部词法环境,

__词法环境__ 存在两种类型

1.__全局环境__（在全局上下文中，或with中）对外部的环境引用为null

2.__函数环境__（在函数环境中）包含了一个 __arguments对象__

__环境记录__,存在两种类型

2.__对象环境记录__（在全局环境中）用于定义 全局执行上下文出现的变量和函数的关联

1.__声明性环境记录__（在函数环境中） 储存 变量/函数/参数 

__arguments对象__,伪数组,包含了 函数参数 与 索引 的映射,及 参数个数.

```js
// 词法环境伪代码
GlobalExectionContext = { // 全局执行上下文
  LexicalEnvironment: { // 词法环境（全局环境）
    EnvironmentRecord: {  // 环境记录（对象）
      Type: "Object",  
      // 标识符绑定在这里 
    outer: <null>  
  }  
}

FunctionExectionContext = { // 函数执行上下文
  LexicalEnvironment: { // 词法环境（函数环境）
    EnvironmentRecord: {  // 环境记录（声明性）
      Type: "Declarative",  
      // 标识符绑定在这里 
    outer: <Global or outer function environment reference>  
  }  
}
```

#### 变量环境（VariableEnvironment）

1.变量环境 就是 词法环境的一种,具有 词法环境 的所有属性

2.在ES6中, 变量环境 与 词法环境 的区别在于,

__词法环境__ 储存 函数声明/变量（let和const）的绑定,

__变量环境__ 仅储存 变量（var）的绑定

#### var 和 let/const

var变量提升是JS的一个重要设计缺陷， 会导致 变量污染 变量覆盖，

在ES6中 用 块级作用域（词法环境） 配合 const let 避免这种缺陷。

执行上下文创建阶段

| 变量类型   | 是否创建 | 是否初始化 | 是否赋值   |
| --------- | -------- | --------- | --------- |
| 形参       | 创建     | 初始化    | 并赋值实参 |
| 函数声明   | 创建     | 初始化    | 并赋值函数体|
| var变量    | 创建     | 初始化    |           |
| let/const |  创建    |           |           |

let/const 创建了但是没有初始化,所以在赋值前被调用即报错 未初始化，__暂时性死区__

### JS执行（ES5）

创建阶段 与ES3类似,创建当前执行上下文内的 this，词法环境，变量环境，outer

注意 执行阶段 变量查找时，同一 执行上下文内 代表 块级作用域的 词法环境 优先级更高

变量查找顺序:

1.沿着当前 执行上下文内 的 词法环境栈 顶向下查找,找到栈底,再找 变量环境，

2.沿着 作用域链，在外部作用域中查找 外一层 的执行上下文，重复第一步。


### 闭包

理解闭包的产生比理解闭包的概念更重要,

__闭包的产生__,根据词法作用域规则,函数的作用域链由函数声明位置决定,声明位置在内部的函数总是可以访问外部函数的变量,

即使内部函数的调用位置,不在其声明的外层函数内,甚至外部函数已经执行结束,

但内部函数 引用的外部函数变量依旧保存在内存中,这些变量的集合称为闭包.

__闭包__,函数与其引用的外部函数词法环境的集合.（函数,自己内部的变量,外部词法环境,可访问的外部变量）


### 感谢

看了二十多篇文章,都把我看懵了...

ES5时代

[面试官：说说执行上下文吧](https://juejin.cn/post/6844904158957404167#comment)

[JS夯实之执行上下文与词法环境](https://juejin.cn/post/6844904145372053511#heading-4)

[彻底搞懂作用域、执行上下文、词法环境](https://juejin.cn/post/7043408377661095967#heading-6)

[[译] 理解 JavaScript 中的执行上下文和执行栈](https://juejin.cn/post/6844903682283143181)

ES3时代文章

[冴羽 JavaScript深入之执行上下文](https://github.com/mqyqingfeng/Blog/issues/8)

[李兵《浏览器工作原理与实践》浏览器中的JavaScript执行机制](https://time.geekbang.org/column/article/119046)


