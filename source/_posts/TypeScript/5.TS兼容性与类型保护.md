---
title: TS兼容性与类型保护
date: 2021-09-25 10:38:00
categories: TS笔记
tags: 
    - TypeScript
---

# TS兼容性

## 接口的兼容性
函数传入的 变量类型 与 声明类型 不匹配TS会进行兼容性检查

原理是Duck-Check,就是说只要目标类型中的属性变量在源类型中都存在就是兼容的

```ts
interface Animal {
    name: string;
    age: number;
}

interface Person {
    name: string;
    age: number;
    gender: number
}
// 要判断目标类型`Person`是否能够兼容输入的源类型`Animal`
function getName(animal: Animal): string {
    return animal.name;
}

let p = {
    name: 'lzy',
    age: 25,
    gender: 0
}

getName(p);
// 只有在传参的时候两个变量之间才会进行兼容性的比较，
// 赋值的时候并不会比较,会直接报错
let a: Animal = {
    name: 'lzy',
    age: 25,
    gender: 0 // 报错
}
```

在第三篇文章 TS接口 中有写道,
__对象字面量 直接作为参数时 会经历 额外属性检查__
__而改写成 对象 再作为参数 传入函数调用,则不会 检查对象上的额外属性__,

很显然,调用函数直接传入 对象字面量,相当于是对形参(对变量)的直接赋值,而
__对 变量赋值 不会进行兼容性检查,不容许额外属性,直接报错__,
函数调用 传参,对于 传入一个 值为对象的变量 这种情况,却是宽容的,允许兼容

猜测:
具有额外属性字面量作为对象 赋值给参数,再作为参数传入函数调用,TS不报错,
是因为TS认为在对象赋值的时候,已经做过变量检查了,是安全的,所以允许兼容.

## 基本类型的兼容性

```ts
//基本数据类型也有兼容性判断
let num : string|number;
let str:string='zhufeng';
num = str;

//只要有toString()方法就可以赋给字符串变量
let num2 : {
  toString():string
}

let str2:string='jiagou';
num2 = str2;
```

## 类的兼容性

__在TS中是结构类型系统，只会对比结构而不在意类型__
```ts
class Animal{ name:string }
class Bird extends Animal{ swing:number }

let a:Animal = new Bird();

//并不是java的那套 '父类兼容子类，但子类不兼容父类'
//仅仅是因为bird 需要的属性 swing:number, new Animal()没有
let b:Bird = new Animal(); //报错
```
下面举例说明 与 类型是不是子类父类 无关,只要结构符合就行
```ts
class Animal{ name:string }
//如果父类和子类结构一样，也可以的
class Bird extends Animal{}

let a:Animal = new Bird();

let b:Bird = new Animal();
// 两个完全无关的类也一样,可以相互赋值,只要结构符合
```

## 函数的兼容性

## 泛型的兼容性

## 枚举的兼容性


# TS类型保护
