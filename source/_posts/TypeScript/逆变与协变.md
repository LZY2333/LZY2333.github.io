---
title: 逆变与协变
date: 2022-11-23 00:01:31
categories: 技术栈
tags: 
    - TypeScript
---

## 啰嗦但大概率能用 --再次彻底弄懂函数TS检查的逆变与协变

### 前言

TypeScript 官网过于简单，对于有后端基础的前端同学来说，可能会看得犯困。

但兼容性这点，TS官方确实算是另辟蹊径，自开山门，允许你有一些"偷懒"，"不正确"的行为。

函数类型的变量约束 具有的 逆变特性，更是让人很难想象 规则制定者的精神高度。

能理解 兼容性， 再学点 内置条件类型，之后，TypeScript 就没有什么坎是过不去的......


TypeScript函数检查的逆变与协变，属于比较"偏门"的知识点，

却是TS学习者，不可缺少，却难以逾越的一道天堑。

当然，TypeScript 同样是 前端学习者，不可缺少，却难以逾越的一道天堑......
### TypeScript函数检查的逆变与协变原理

要理解 __逆变与协变__，

1. 首先要明确，type约束，实际上是约束 __变量__ 可以接收哪种类型的 __值__

2. 其次要理解，对变量来说 函数类型的约束，实际上是 

__约束 入参 和 返回值，只要满足这两个要求，赋值什么函数都行__

__而兼容性的存在，放宽了对 入参 和 返回值 的要求，做到只要能安全执行就行__

3. 对于函数变量来说，存在 赋值 和 调用，两处类型检查。

__赋值处检查，(函数)变量type 与 (函数)值type 的兼容性__

__调用处检查，(函数)变量type 与 (函数)值入参type 的兼容性__

__注意! 逆变与协变 这种兼容性 是存在于 赋值处的 兼容性检查，__

而要理解 逆变与协变 的合理性，则要站在 __调用处__ 的类型检查角度 来感受。

这里是总结性发言，第3点没理解不要紧，这次会层层细说。

### 什么是兼容性

就是说一个被约束了类型的 __变量__ ，可以兼容其他类型的 __值__，

就像 一个被约束类型为父类的 __变量__ 依旧可以被 赋值 为子类的实例 __值__

(因为子类必然具有父类的所有属性,这样调用时按父类的标准来调用是安全的)。

被 基本类型 接口类型 类类型 函数类型 泛型 约束的 变量，

均存在不同的兼容性，来放宽值的类型要求。

这次想要解释的就是 __函数兼容性__

而 函数的约束，主要体现在 __入参__ 和 __返回值__ 上，其兼容性也是如此。


理解什么是 入参数量上的兼容，能更好的理解 函数类型变量 逆变和协变 的合理性

### 入参数量上的兼容

1. 变量中 函数类型的约束，为 __入参__ 和 __返回值__

2. 其中， __入参数量的减少可以被兼容(但类型依旧要相同)__


`sum` 被约束为，可以被赋值为 需要两个入参 的函数(而不管这个函数是干啥的)

而因为兼容性，而实际上 `sum` 的值 还可以是 只需要一个入参的函数

```ts
type sumFunc = (a:number，b:number)=>number;
let sum:sumFunc;
function f1(a:number，b:number):number{
  return a+b;
}
//可以省略一个参数
function f2(a:number):number{
   return a;
}
//可以省略二个参数
function f3():number{
    return 0;
}
 //多一个参数可不行
function f4(a:number，b:number，c:number){
    return a+b+c;
}
sum = f1;
sum = f2;
sum = f3;
sum = f4; // 报错
```

由于 `sum` 被限定了类型 `sumFunc`，该类型 要两个参数。

那么在 `sum` 被调用处，TS就会要求填入两个参数。

而实际上 `sum` 代表的函数 代表的值，

可能是一个只需要一个参数的函数(如:`f2`，作用就是返回入参)，

`f2`，被传了两个参数，仅仅是用不到第二个参数而已，函数不会因此报错，对吧？

所以很安全，所以允许 变量`sum:sumFunc`兼容 值`f2`


因为 __兼容性__ 的存在，只要是能安全执行，即使不符合 类型`sumFunc`的定义，

TS认为 __入参数量减少__ 是安全的，是兼容的，所以也给了通过，允许将值`f2` 赋值给 变量`sum`

这就是 __兼容性__，存在的合理性。


### 缓一缓

看完第一个例子，应该理解了(再次重复开头的话):

对变量来说 函数类型的约束，实际上是  __约束 入参 和 返回值，只要满足这两个要求，赋值什么函数都行__

当 __被约束的变量__ 与 __其被赋予的值__ 存在type差异时，TS将报错， 

但 这种type差异，在一定范围上是被允许而不报错的，这就是 __兼容性__，

而难以理解的点在于: 

0. 允许差异的范围判断标准是什么？ __是否安全__

1. 对于函数type来说，这个范围是多大？ __入参数量减少的值 & 符合逆变与协变规则的值__

2. 什么是逆变与协变？为什么说这样就安全？

### 入参类型的兼容(逆变) 返回值类型的兼容(协变)

### 什么是逆变与协变？

__在给限定了 函数类型的变量 赋值函数时__

赋值给 变量的 函数

其参数 可以是 比变量类型定义里 要求的属性 更少(逆变)

返回值 可以是 比变量类型定义里 要求的属性 更多(协变)

简化版:

__给变量赋值的函数 参数可以属性更少，返回值可以属性更多__。

理解版:

__用于赋值的函数的 参数 的属性 必须 比 被赋值的变量的要求 更少__

__用于赋值的函数的 返回值 的属性 必须 比 被赋值的变量的要求 更多__

返回值的协变很好理解，这里主要讲逆变

### 为什么满足 逆变 会安全

这里直接复制开头第3点

__赋值处检查，(函数)变量type 与 (函数)值type 的兼容性__

__调用处检查，(函数)变量type 与 (函数)值入参type 的兼容性__

调用处TS检查，会要求 入参type，属性数大于等于 变量type的入参约束。

(传入的属性更多，多余的属性用不到，但是该有的属性都有，很安全!)

赋值处TS检查，会要求 值type的入参type，__属性数小于等于 变量type的入参约束(逆变)__

变量type 由此有了一个 __承上启下__ 的作用,

__真实值的入参type__ <= __变量type的入参约束(逆变)__ <= __调用时的入参type__

调用处的TS检查已经保证了第二个`<=`，赋值处存在 __逆变__ 则保证了第一个 `<=`。

如此则保证了，入参属性是满足函数的调用要求的，那么该次调用就必然是安全的。

```ts
class Parent {
    house() { }
}
class Child extends Parent {
    car() { }
}
class Grandson extends Child {
    sleep() { }
}

// error: 赋值处，(逆变) 这里赋值 入参可以 Parent 或 Child, 不能 Grandson
const fun1: (arg: Child) => Child = (arg: Grandson): Grandson => {
    return new Grandson()
}
// error：调用处，这里入参可以是 Grandson 或 Child，不能 Parent
fun1(new Parent())

// 正解，值的入参type 只能 小于等于 fun2 的type要求
const fun2: (arg: Child) => Child = (arg: Child): Grandson => {
    return new Grandson()
}
// 正解，调用处的入参 只能 大于等于 fun2 的type要求
fun2(new Grandson())

```

### 结束语

逆变确实很难理解，之前写过一篇逆变与协变的文章，现在去看也有点蒙，遂写了一篇新的。

看到这里再回去看开头的总结，应该能体会到逆变的逻辑吧？

本文自己读了很多遍，且基于自己上一篇文章进行改动，已经尽量解释，尽量精简。

日常熬夜，感谢点赞，欢迎讨论。

寒冬已来，大家应该加紧 "囤货" 啊！
