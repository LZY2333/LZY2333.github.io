---
title: React技术解密--理念篇笔记
date: 2023-02-15 09:08:51
categories: 技术栈
tags: 
    - React
---

## React技术解密--理念篇笔记

## React15架构是什么

__Reconciler（协调器）操作虚拟DOM__

1. 调用JSX生成虚拟DOM

2. 新旧虚拟DOM对比与更新

3. 通知 Renderer（渲染器）执行

__Renderer（渲染器）生成真实DOM__

不同的Renderer，将虚拟DOM生成不同的平台数据结构

__React15的缺点 Reconciler同步递归不可中断架构导致卡顿__ 

Reconciler 递归生成新虚拟DOM树的过程无法中断，递归更新时间超过了16ms，用户会感觉卡顿掉帧。

无法中断让渡给渲染线程，如果中途中断函数调用，则执行栈销毁，无法复用之前的中间状态。

Reconciler Renderer 交替执行

> React从理念上入手理解分为 Reconciler 和 Renderer 
> React从执行脉络上入手学习分为 初始化 和 更新 两个部分。

## React16架构是什么

__React16核心目的__ : 将 __同步递归不可中断更新架构__ 变为 __异步可中断更新架构__

__使用 fiber 重构 Reconciler，引入 Scheduler__

Scheduler（调度器）—— 判断浏览器帧空闲时间,判断任务优先级,任务中断与开始
Reconciler（协调器）—— 操作虚拟DOM，标记出变更
Renderer（渲染器）—— 将虚拟DOM的变更体现在真实DOM上
Scheduler Reconciler 随时可因 __更高优先级任务__  __当前帧剩余时间不足__ 中止

__render阶段__,Reconciler工作的阶段。
__commit阶段__,Renderer工作的阶段。
render与commit阶段统称为work，即React在工作中。
相对应的，如果任务正在Scheduler内调度，就不属于work。

### Scheduler

[React 之从 requestIdleCallback 到时间切片](https://juejin.cn/post/7167335700424196127)

__requestIdleCallback__: 浏览器提供的Api,其注册的回调函数会在空闲阶段执行,但是具有 浏览器兼容性, 触发频率不稳定 等问题.

__Scheduler库__: 由React实现的功能更完备的`requestIdleCallback`polyfill,判断浏览器帧空闲时间,额外能判断任务优先级.

React 早期采用的是 requestAnimationFrame + postMessage 来实现

### Reconciler

React16的Reconciler 从 递归 变成了可中断的 循环

## Fiber是什么

可简单认为是,以链表结构相连的 虚拟DOM,同时挂载了 组件状态和更新操作

__一种架构名称__ : React16的Reconciler基于Fiber节点实现，被称为Fiber Reconciler。

React15的Reconciler采用递归的方式执行，数据保存在递归调用栈中，所以被称为stack Reconciler。

__一种数据结构名称__ : 一个Fiber节点对应一个React element，包含组件的类型,虚拟DOM、真实DOM等信息。

__React的最小工作单元__ : 运行时,Fiber 储存了该组件改变的状态、要执行的操作（删除/插入/更新...）。

```js
function FiberNode(
    tag: WorkTag,
    pendingProps: mixed,
    key: null | string,
    mode: TypeOfMode,
) {
    // 作为静态数据结构的属性
    this.tag = tag;
    this.key = key;
    this.elementType = null;
    this.type = null;
    this.stateNode = null;

    // 作为架构
    // 用于连接其他Fiber节点形成Fiber树
    this.return = null;
    this.child = null;
    this.sibling = null;
    this.index = 0;

    this.ref = null;

    // 作为动态的工作单元的属性
    this.pendingProps = pendingProps;
    this.memoizedProps = null;
    this.updateQueue = null;
    this.memoizedState = null;
    this.dependencies = null;

    this.mode = mode;

    this.effectTag = NoEffect;
    this.nextEffect = null;

    this.firstEffect = null;
    this.lastEffect = null;

    // 调度优先级相关
    this.lanes = NoLanes;
    this.childLanes = NoLanes;

    // 指向该fiber在另一次更新时对应的fiber
    this.alternate = null;
}
```

[React技术揭秘--Fiber的结构](https://react.iamkasong.com/process/fiber.html#fiber%E7%9A%84%E5%90%AB%E4%B9%89)

## Fiber的工作原理(Fiber树篇)

帧动画绘制时会采用 __双缓存__ 机制,在内存中绘制帧,再直接替换当前帧,减少白屏.

### Fiber架构模拟了双缓存机制

React存在两颗Fiber树,当前页面内容对应的 `current Fiber树`, 内存中构建的 `workInProgress Fiber树`

`workInProgress Fiber树`构建完成交给Renderer渲染，

应用根节点的current指针指向`workInProgress Fiber树`，`workInProgress Fiber树`就变为`current Fiber树`。

每次状态更新都会产生新的`workInProgress Fiber树`，通过current与workInProgress的替换，完成DOM更新。

__在内存中构建树,可随时终止更新,让渡浏览器主线程,构建完毕一次性commit渲染视图__

`current Fiber树` 节点为 current fiber,`workInProgress Fiber树` 节点为 workInProgress fiber,他们通过alternate属性连接。

```js
currentFiber.alternate === workInProgressFiber;
workInProgressFiber.alternate === currentFiber;
```

### mount 与 update 流程

__mount时,__

ReactDOM.render 会创建 `fiberRoot` 应用根节点,其 current 指向 当前页面内容对应的 `current Fiber树`.

render阶段,在内存中 依组件次序 各自创建 虚拟DOM转换为 Fiber,连接构成Fiber树,此时为 `workInProgress Fiber树`.

render阶段,构建 `workInProgress Fiber树` 时会尝试复用 `current Fiber树` 中已有的Fiber节点内的属性.

commit阶段, `workInProgress Fiber树` 渲染到页面,`FiberRootNode.current`指向其,使其变成 `current Fiber 树`.

__update时,__

点击触发状态改变,这会 开启一次新的render阶段并构建一棵新的`workInProgress Fiber 树`。

与 __mount时__ 一样,render阶段,尝试复用,完成构建进入commit阶段完成渲染,`current Fiber 树`再次变更.

[React技术揭秘--Fiber的工作原理](https://react.iamkasong.com/process/doubleBuffer.html#%E4%BB%80%E4%B9%88%E6%98%AF-%E5%8F%8C%E7%BC%93%E5%AD%98)


## Fiber的工作原理(Fiber节点篇)

[React技术揭秘--架构篇Render阶段](https://react.iamkasong.com/process/reconciler.html)







## JSX是什么

JSX 是一种语法糖,就像 async函数是Promise的语法糖.

1. babel对JSX语法进行正则匹配，通过AST语法树，将JSX代码替换为了`React.createElement()`

2. `React.createElement()` 运行时的返回值就是 虚拟DOM,也是 ReactElement

3. 组件 mount 时, Reconciler 将 虚拟DOM 生成 Fiber节点

JSX => `React.createElement()` => 虚拟DOM => Fiber

> React17开始将JSX库单独提出，以便其他库使用JSX语法，而可以不引入React, `React.createElement()` 变成了 `jsx()`

## 代数效应(未完成,待加深理解)

代数效应 是 函数式编程 中的一个概念，

通过使用 代数语法 将副作用从 函数式编程 抽离, 保存函数式编程纯粹,避免副作用且无需关注其实现。

使用代数效益的作用: __只需要关注纯粹业务逻辑,无需考虑副作用的管理.

例如:

代数效应 与 Hooks: 只需知道 useState 会保存并返回state, 无需关注state在Hook中是如何保存的.

__Fiber的存在就是践行了代数效应__

### 为什么React不使用 Generator 实现异步可中断 的代数效应

[Fiber Principles: Contributing To Fiber](https://github.com/facebook/react/issues/7942)

1. Generator函数被调用时,需要调用者使用额外的语法

2. Generator

单一优先级任务的中断与继续,使用 Generator 可以实现 异步可中断更新

高优先级任务插队, 的情况则无法使用 Generator

Generator执行的中间状态是上下文关联的，所以计算y时无法复用之前已经计算出的x，需要重新计算。

如果通过全局变量保存之前执行的中间状态，又会引入新的复杂度。

基于这些原因，React没有采用Generator实现协调器。